*GitHub Repository "RIZAmohammadkhan/GuiKeyStandalone"*

'''--- README.md ---
# GuiKeyStandalone - Activity Monitoring Suite

GuiKeyStandalone is a comprehensive Rust-based suite for monitoring user activity (keystrokes, clipboard, active applications) on Windows machines and securely transmitting this data to a local server for review. It consists of three main components:

1.  **Activity Monitor Client Core (`activity_monitor_client_core`)**: A Windows client application that performs the monitoring, encrypts the data, and sends it to the server.
2.  **Local Log Server (`local_log_server`)**: An Actix-web server that receives encrypted logs, stores them in an SQLite database, and provides a web interface to view them.
3.  **Package Generator GUI (`activity_generator_gui`)**: An `egui`-based graphical tool that embeds the client and server binaries and assets. It allows an operator to generate unique encryption keys and client IDs, configure settings, and produce deployment packages for both the client (for remote machines) and the server (for the operator's machine).

## Vision & Purpose

The primary goal of GuiKeyStandalone is to provide a self-hostable solution for activity monitoring where the operator has full control over the data. The `activity_generator_gui` facilitates a "remote-first" deployment:

*   **Operator**: Uses the Generator GUI to create a unique client package.
*   **Server Setup (Operator)**: The operator deploys the `LocalLogServer_Package` (generated by the GUI) on a machine they control. They are responsible for making this server accessible via a public HTTPS URL (e.g., using a tunneling service like Cloudflare Tunnel or ngrok, or by setting up a reverse proxy).
*   **Client Deployment (Operator)**: The operator distributes the `ActivityMonitorClient_Package` (generated by the GUI) to target Windows machines they wish to monitor.
*   **Data Flow**: The client on the target machine monitors activity, encrypts it with the unique key, and sends it to the operator's publicly accessible server URL.
*   **Data Review (Operator)**: The operator can view the collected logs through the web interface provided by their `local_log_server` instance.

**Security and ethical use are paramount. This tool should only be used in compliance with all applicable laws, regulations, and with explicit consent where required.**

## Features

**Package Generator GUI (`activity_generator_gui`)**:
*   Self-contained: Embeds client/server template binaries and server web assets.
*   Generates unique AES-256 encryption keys and UUID client IDs.
*   Configures client to send data to a user-specified public server URL.
*   Configures server's local listening address, database path, and log retention policies.
*   Outputs two distinct packages:
    *   `ActivityMonitorClient_Package`: For distribution to target machines.
    *   `LocalLogServer_Package`: For the operator to run their central server.
*   Generates a `README_IMPORTANT_INSTRUCTIONS.txt` with setup guidance for the generated packages.
*   Cross-platform (GUI itself can run on Windows, Linux, macOS if eframe supports it), but generates Windows executables for client/server.

**Activity Monitor Client Core (`activity_monitor_client_core`)**:
*   Monitors:
    *   Keyboard input (character data and special keys).
    *   Clipboard copy events (text content).
    *   Foreground application name and window title.
*   Data Processing: Aggregates raw events into "sessions" based on active application.
*   Local Caching: Stores logs locally in a JSONL file (`activity_data.jsonl`) if the server is unreachable.
    *   Implements efficient log reading and removal from the cache file using temporary files to avoid full rewrites for large caches.
    *   Configurable local cache retention period and max file size.
*   Encryption: Encrypts log data using AES-256-GCM before transmission.
*   Networking: Sends encrypted log batches to the configured server URL.
    *   Handles retries on network failure.
*   Autostart: Configures itself to run on Windows startup (via Registry Run key).
*   Diagnostics: Detailed internal logging using `tracing`.

**Local Log Server (`local_log_server`)**:
*   API Endpoint: Receives encrypted log batches from clients via `/api/log`.
*   Decryption: Decrypts incoming payloads using the shared AES-256 key.
*   Storage: Stores deserialized log events in an SQLite database.
    *   Database operations are performed on a blocking thread pool to keep the server responsive.
*   Web Interface:
    *   Provides a web UI (accessible via `/logs`) to view collected logs.
    *   Dark theme with teal accents for better readability.
    *   Paginated log display.
*   Log Retention: Automatically deletes old logs from the database based on a configurable retention period.
    *   Deletion check interval is configurable.
*   Diagnostics: Internal logging using `tracing`.

## Project Structure

The project is a Cargo workspace with three main crates:

```
GuiKeyStandalone/
├── Cargo.toml                (Workspace)
├── docs/
│   └── GENERATOR_GUIDE.md    (User guide for the Generator GUI)
│
├── activity_generator_gui/   (The GUI packager)
│   ├── Cargo.toml
│   ├── src/
│   │   ├── app_state.rs
│   │   ├── config_models.rs
│   │   ├── errors.rs
│   │   ├── generator_logic.rs
│   │   ├── main.rs
│   │   └── embedded_assets/  (Contains binaries and server assets to be embedded)
│   │       ├── client_template_payload.bin
│   │       ├── server_template_payload.bin
│   │       └── server_package_content/ (static CSS, HTML templates)
│   │           ├── static/
│   │           └── templates/
│
├── activity_monitor_client_core/ (The Windows monitoring client)
│   ├── Cargo.toml
│   ├── App.manifest
│   ├── build.rs
│   ├── src/ (app_config, core_monitors, errors, event_types, network, processing, services, storage, etc.)
│
├── local_log_server/         (The log receiving server and web UI)
│   ├── Cargo.toml
│   ├── src/ (app_config, application, domain, errors, infrastructure, presentation, etc.)
│   ├── static/ (Original CSS/JS for server UI - copied into generator for embedding)
│   └── templates/ (Original Askama HTML templates - copied into generator for embedding)
│
└── target/                     (Build outputs for all crates)
```

## Getting Started / Building

### Prerequisites
*   Rust toolchain (latest stable recommended).
*   For `activity_monitor_client_core`: Windows development environment (MSVC or GNU toolchain for Windows).
*   (Optional but recommended for generator workflow) A script or manual process to copy compiled client/server binaries and server assets into the `activity_generator_gui/src/embedded_assets/` directory.

### Build Steps

1.  **Build the Client and Server Cores:**
    These are the "template" binaries that the Generator GUI will embed.
    ```
    cargo build --release --package activity_monitor_client_core
    cargo build --release --package local_log_server
    ```

2.  **Prepare Assets for Generator GUI Embedding:**
    *   Locate the compiled binaries (e.g., in `GuiKeyStandalone/target/release/`).
    *   Copy `activity_monitor_client_core.exe` to `GuiKeyStandalone/activity_generator_gui/src/embedded_assets/client_template_payload.bin`.
    *   Copy `local_log_server.exe` to `GuiKeyStandalone/activity_generator_gui/src/embedded_assets/server_template_payload.bin`.
    *   Copy the contents of `GuiKeyStandalone/local_log_server/static/` into `GuiKeyStandalone/activity_generator_gui/src/embedded_assets/server_package_content/static/`.
    *   Copy the contents of `GuiKeyStandalone/local_log_server/templates/` into `GuiKeyStandalone/activity_generator_gui/src/embedded_assets/server_package_content/templates/`.

3.  **Build the Generator GUI:**
    ```
    cargo build --release --package activity_generator_gui
    ```
    The self-contained `activity_generator_gui.exe` will be in `GuiKeyStandalone/target/release/`.

### Running the Generator GUI
1.  Execute the compiled `activity_generator_gui.exe`.
2.  **Configure Public Server URL**: This is crucial. Enter the full HTTPS URL (e.g., `https://your-tunnel.example.com/api/log`) where clients will send data. You are responsible for making your server (from `LocalLogServer_Package`) accessible at this URL.
3.  **Select Output Directory**: Choose where the `ActivityMonitorClient_Package` and `LocalLogServer_Package` will be saved.
4.  Adjust any other server or client settings as needed.
5.  Click "Generate Deployment Packages".
6.  Follow the instructions in the generated `README_IMPORTANT_INSTRUCTIONS.txt` found in your output directory.

## Key Technologies Used
*   **Rust**: Core language for all components.
*   **`egui` (via `eframe`)**: For the cross-platform Package Generator GUI.
*   **`actix-web`**: For the Local Log Server's web framework.
*   **`rusqlite`**: For SQLite database interaction in the server.
*   **`askama`**: For HTML templating in the server's web UI.
*   **`tokio`**: Asynchronous runtime for client and server.
*   **`serde`**: For serialization/deserialization (JSON, TOML).
*   **`aes-gcm`**: For AES-256-GCM encryption of log data.
*   **`windows-sys`**: For low-level Windows API calls in the client (hooks, process info).
*   **`include_dir` / `include_bytes!`**: For embedding assets into the Generator GUI.
*   **`tracing`**: For structured logging across components.

## Important Considerations

*   **Security**:
    *   The generated encryption key is the primary protection for the data payload.
    *   The operator is responsible for securing the machine running the `local_log_server` and ensuring its public endpoint (e.g., via a tunnel) is appropriately configured (ideally with HTTPS).
    *   Consider network security policies, firewalls, and regular software updates.
*   **Ethics and Legality**:
    *   Activity monitoring can have significant privacy implications.
    *   **Always ensure you have explicit consent from individuals whose activity is being monitored if they are not you.**
    *   Comply with all local and international laws and regulations regarding data privacy and employee/user monitoring.
    *   This tool is provided as-is; the user (operator) assumes all responsibility for its ethical and legal use.
*   **Resource Management**:
    *   The client is designed to be relatively lightweight but will consume some CPU and I/O for monitoring and local caching.
    *   The server's resource usage will depend on the number of clients and the volume of logs. SQLite is generally efficient for single-server setups.

## Future Enhancements / To-Do (Potential)
*   **HTTPS for Server**: Directly support or provide clearer guidance for setting up HTTPS for the `local_log_server` (e.g., integration with `rustls` or `openssl` in Actix, or detailed reverse proxy examples).
*   **Generator `build.rs`**: Automate the copying of template binaries and server assets into `src/embedded_assets` as part of the `activity_generator_gui` build process.
*   **Advanced Client Configuration**: Expose more client settings (like `processor_periodic_flush_interval_secs`) in the Generator GUI.
*   **Server UI Filtering/Search**: Add capabilities to filter or search logs in the web UI (e.g., by application name, date range, client ID).
*   **Client Heartbeat/Status**: Implement a mechanism for clients to send periodic status updates to the server.
*   **Remote Client Management (Advanced)**: Basic commands or status requests from server to client (highly complex and security-sensitive).
*   **Improved Error Reporting**: More granular error details in status messages or logs for all components.

## Contributing
Contributions, bug reports, and feature requests are welcome! Please open an issue or pull request on the GitHub repository.

'''
'''--- activity_generator_gui/Cargo.toml ---
[package]
name = "activity_generator_gui"
version = "0.1.0"
edition = "2024"

[dependencies]
eframe = "0.27.2"
serde = { version = "1.0.196", features = ["derive"] }
toml = "0.8.8"
# serde_json = "1.0" # Not needed if server config is also TOML
uuid = { version = "1.7.0", features = ["v4"] }
rand = "0.8.5"
hex = "0.4.3"
rfd = "0.14.0"
fs_extra = "1.3.0"
thiserror = "1.0.57"
chrono = "0.4.33" # For timestamp in panic log
include_dir = "0.7"

[build-dependencies]
# embed-resource = "1.7"
'''
'''--- activity_generator_gui/src/app_state.rs ---
// src/app_state.rs (for activity_generator_gui)
use crate::config_models::{ClientSettingsOutput, LocalServerConfigOutput};
use std::path::PathBuf; // Path is not directly used here anymore

#[derive(Clone, Debug)]
pub struct GeneratorAppState {
    pub output_dir_path_str: String,
    pub public_server_url_str: String, // For client's server_url (e.g., https://my.tunnel.com/api/log)
    pub client_config: ClientSettingsOutput, // Client settings modified by user
    pub server_config: LocalServerConfigOutput, // Server settings (listen_address, db_path, retention) modified by user
    pub status_message: String,
    pub operation_in_progress: bool,
    pub generated_key_hex_display_snippet: String,
    pub generated_client_id_display: String,
}

impl Default for GeneratorAppState {
    fn default() -> Self {
        Self {
            output_dir_path_str: String::new(),
            // Default to common local setup, user MUST change this for remote deployment.
            // It's critical this ends with /api/log if that's what the server expects.
            public_server_url_str: "http://127.0.0.1:8090/api/log".to_string(),
            client_config: ClientSettingsOutput::new_with_defaults(),
            server_config: LocalServerConfigOutput::new_with_defaults(),
            status_message: "Welcome! Configure Public Server URL, Output Dir, and other settings.".to_string(),
            operation_in_progress: false,
            generated_key_hex_display_snippet: "N/A".to_string(),
            generated_client_id_display: "N/A".to_string(),
        }
    }
}

impl GeneratorAppState {
    // Removed get_client_template_exe_path
    // Removed get_server_template_exe_path
    // Removed get_server_static_assets_source_path
    // Removed get_server_templates_source_path

    pub fn get_output_dir_path(&self) -> Option<PathBuf> {
        if self.output_dir_path_str.is_empty() { None } else { Some(PathBuf::from(&self.output_dir_path_str)) }
    }

    // Removed synchronize_dependent_configs
}
'''
'''--- activity_generator_gui/src/config_models.rs ---
// src/config_models.rs (for activity_generator_gui)
use serde::Serialize;

// --- For client_settings.toml (to be used by activity_monitor_client_core.exe) ---
#[derive(Serialize, Debug, Clone)]
pub struct ClientSettingsOutput {
    pub server_url: String,
    pub encryption_key_hex: String,
    pub client_id: String,
    pub sync_interval: u64,
    pub processor_periodic_flush_interval_secs: u64,
    pub internal_log_level: String,
    pub log_file_path: String,
    pub app_name_for_autorun: String,
    pub local_log_cache_retention_days: u32,
    pub retry_interval_on_fail: u64,
    pub max_retries_per_batch: u32,
    pub max_log_file_size_mb: Option<u64>,
    pub max_events_per_sync_batch: usize,
    pub internal_log_file_dir: String,
    pub internal_log_file_name: String,
    pub client_id_file: Option<String>,
}

impl ClientSettingsOutput {
    pub fn new_with_defaults() -> Self {
        Self {
            server_url: "http://127.0.0.1:8090/api/log".to_string(),
            encryption_key_hex: String::new(),
            client_id: String::new(),
            sync_interval: 60,
            processor_periodic_flush_interval_secs: 120,
            internal_log_level: "info".to_string(),
            log_file_path: "activity_data.jsonl".to_string(), // MODIFIED HERE from .log.bin
            app_name_for_autorun: "SystemActivityAgent".to_string(),
            local_log_cache_retention_days: 7,
            retry_interval_on_fail: 60,
            max_retries_per_batch: 3,
            max_log_file_size_mb: Some(20),
            max_events_per_sync_batch: 200,
            internal_log_file_dir: "client_logs".to_string(),
            internal_log_file_name: "monitor_client_diag.log".to_string(),
            client_id_file: None,
        }
    }
}

// --- For local_server_config.toml (to be used by local_log_server.exe) ---
#[derive(Serialize, Debug, Clone)]
pub struct LocalServerConfigOutput {
    pub listen_address: String,
    pub encryption_key_hex: String,
    pub database_path: String,
    pub log_retention_days: u32,
}

impl LocalServerConfigOutput {
    pub fn new_with_defaults() -> Self {
        Self {
            listen_address: "0.0.0.0:8090".to_string(), // MODIFIED HERE
            encryption_key_hex: String::new(),
            database_path: "activity_database.sqlite".to_string(),
            log_retention_days: 30,
        }
    }
}
'''
'''--- activity_generator_gui/src/embedded_assets/server_package_content/static/css/style.css ---
:root {
    --bg-color: #1e1e2e; /* Dark background */
    --bg-color-light: #2a2a3c; /* Slightly lighter dark for cards/sections */
    --text-color: #cdd6f4; /* Light text for readability */
    --text-color-muted: #a6adc8; /* Muted text for less important info */
    --text-color-dark: #11111b; /* For light backgrounds if any */

    --primary-accent: #89dceb; /* Teal */
    --primary-accent-hover: #96e2f0;
    --primary-accent-darker: #77c2cf;

    --border-color: #45475a; /* Subtle borders */
    --card-shadow: 0 2px 8px rgba(0,0,0,0.3);

    --font-sans: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    --font-mono: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;

    --spacing-unit: 8px;
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html {
    font-size: 16px; /* Base font size */
}

body {
    font-family: var(--font-sans);
    line-height: 1.6;
    background-color: var(--bg-color);
    color: var(--text-color);
    display: flex;
    flex-direction: column;
    min-height: 100vh;
}

.site-wrapper {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.container {
    width: 90%;
    max-width: 1200px; /* Limit max width for very wide screens */
    margin: 0 auto;
    padding-left: calc(var(--spacing-unit) * 2);
    padding-right: calc(var(--spacing-unit) * 2);
}

.site-header {
    background-color: var(--bg-color-light);
    color: var(--primary-accent);
    padding: calc(var(--spacing-unit) * 2) 0;
    border-bottom: 1px solid var(--border-color);
    box-shadow: var(--card-shadow);
}

.site-header h1 {
    font-size: 1.8rem;
    font-weight: 600;
    text-align: center;
}

.site-content {
    padding-top: calc(var(--spacing-unit) * 3);
    padding-bottom: calc(var(--spacing-unit) * 3);
    flex: 1;
}

/* Log Entry Styling */
.log-entries-container {
    display: grid;
    gap: calc(var(--spacing-unit) * 2.5);
}

.log-entry {
    background-color: var(--bg-color-light);
    border: 1px solid var(--border-color);
    border-radius: calc(var(--spacing-unit) / 2);
    padding: calc(var(--spacing-unit) * 2);
    box-shadow: var(--card-shadow);
    transition: transform 0.2s ease-in-out;
}
/* .log-entry:hover {
    transform: translateY(-2px);
} */

.log-entry-header {
    border-bottom: 1px solid var(--border-color);
    padding-bottom: var(--spacing-unit);
    margin-bottom: calc(var(--spacing-unit) * 1.5);
}

.log-entry-header .app-name {
    color: var(--primary-accent);
    font-size: 1.4rem;
    margin-bottom: calc(var(--spacing-unit) / 2);
}

.log-entry-header .window-title {
    font-size: 0.9rem;
    color: var(--text-color-muted);
}
.log-entry-header .window-title strong {
    color: var(--text-color);
}

.log-entry-details p {
    margin-bottom: calc(var(--spacing-unit) / 2);
    font-size: 0.9rem;
}
.log-entry-details strong {
    color: var(--primary-accent-darker);
    font-weight: 500;
}

.log-data h4 {
    font-size: 1rem;
    color: var(--primary-accent);
    margin-top: calc(var(--spacing-unit) * 1.5);
    margin-bottom: calc(var(--spacing-unit) /2);
}

.typed-text-section .typed-text-content {
    background-color: var(--bg-color); /* Even darker for pre blocks */
    border: 1px solid var(--border-color);
    padding: var(--spacing-unit);
    border-radius: calc(var(--spacing-unit) / 2);
    white-space: pre-wrap;
    word-wrap: break-word;
    max-height: 250px; /* Slightly more room */
    overflow-y: auto;
    font-size: 0.85rem;
    color: var(--text-color); /* Ensure pre text is also light */
}

.clipboard-section .clipboard-list {
    list-style: none; /* Remove default bullets */
    padding-left: 0;
    font-size: 0.85rem;
}

.clipboard-section .clipboard-list li {
    padding: calc(var(--spacing-unit) / 2) 0;
    border-bottom: 1px dashed var(--border-color);
}
.clipboard-section .clipboard-list li:last-child {
    border-bottom: none;
}

.clip-time {
    font-weight: 500;
    color: var(--primary-accent-darker);
}
.clip-preview {
    color: var(--text-color);
}
.clip-meta {
    font-size: 0.8rem;
    color: var(--text-color-muted);
}

.log-entry-footer {
    margin-top: calc(var(--spacing-unit) * 1.5);
    padding-top: var(--spacing-unit);
    border-top: 1px solid var(--border-color);
}

.event-meta {
    font-size: 0.75rem;
    color: var(--text-color-muted);
    text-align: right;
}

.monospace {
    font-family: var(--font-mono);
}

/* Pagination */
.pagination {
    margin: calc(var(--spacing-unit) * 3) 0;
    text-align: center;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: var(--spacing-unit);
}

.pagination .pagination-link {
    color: var(--primary-accent);
    text-decoration: none;
    padding: var(--spacing-unit) calc(var(--spacing-unit) * 1.5);
    border: 1px solid var(--primary-accent);
    border-radius: calc(var(--spacing-unit) / 2);
    transition: background-color 0.2s, color 0.2s;
}

.pagination .pagination-link:hover {
    background-color: var(--primary-accent);
    color: var(--text-color-dark);
}

.pagination .pagination-link.disabled {
    color: var(--text-color-muted);
    border-color: var(--border-color);
    pointer-events: none;
}
.pagination .pagination-link.disabled:hover {
    background-color: transparent;
}

.pagination .page-info {
    padding: var(--spacing-unit) calc(var(--spacing-unit) * 1.5);
    color: var(--text-color-muted);
}

.no-logs-message {
    text-align: center;
    font-size: 1.1rem;
    color: var(--text-color-muted);
    padding: calc(var(--spacing-unit) * 4) 0;
}

.error-page .error-message {
    color: #ff79c6; /* Pink for errors in dark theme */
    background-color: var(--bg-color-light);
    border: 1px solid #ff79c6;
    padding: calc(var(--spacing-unit) * 2);
    margin-bottom: calc(var(--spacing-unit) * 2);
    border-radius: calc(var(--spacing-unit) / 2);
}
.error-page h2 {
    color: #ff79c6;
}
.error-page a {
    color: var(--primary-accent);
}

.site-footer {
    background-color: var(--bg-color);
    color: var(--text-color-muted);
    text-align: center;
    padding: calc(var(--spacing-unit) * 2) 0;
    font-size: 0.85rem;
    border-top: 1px solid var(--border-color);
}

/* Scrollbar styling (optional, WebKit browsers) */
::-webkit-scrollbar {
    width: 10px;
    height: 10px;
}
::-webkit-scrollbar-track {
    background: var(--bg-color);
}
::-webkit-scrollbar-thumb {
    background: var(--border-color);
    border-radius: 5px;
}
::-webkit-scrollbar-thumb:hover {
    background: var(--primary-accent-darker);
}
'''
'''--- activity_generator_gui/src/embedded_assets/server_package_content/templates/base.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Local Activity Log Viewer{% endblock %}</title>
    <link rel="stylesheet" href="/static/css/style.css">
    {% block head_extra %}{% endblock %}
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <div class="container">
                <h1>{% block header_title %}Activity Logs{% endblock %}</h1>
            </div>
        </header>
        <main class="site-content">
            <div class="container">
                {% block content %}{% endblock %}
            </div>
        </main>
        <footer class="site-footer">
            <div class="container">
                <p>Local Log Server</p>
            </div>
        </footer>
    </div>
    {% block scripts %}{% endblock %}
</body>
</html>
'''
'''--- activity_generator_gui/src/embedded_assets/server_package_content/templates/error_page.html ---
{% extends "base.html" %}

{% block title %}Error{% endblock %}
{% block header_title %}An Error Occurred{% endblock %}

{% block content %}
    <div class="error-page">
        <h2>{{ error_title }}</h2>
        <p class="error-message">{{ error_message }}</p>
        <p><a href="/logs">Return to logs</a></p>
    </div>
{% endblock %}
'''
'''--- activity_generator_gui/src/embedded_assets/server_package_content/templates/logs_view.html ---
{% extends "base.html" %}

{% block title %}View Logs - Page {{ current_page }}{% endblock %}
{% block header_title %}Activity Log Viewer - Page {{ current_page }} of {{ total_pages }}{% endblock %}

{% block content %}
    <div class="log-entries-container">
    {% if display_events.is_empty() %}
        <p class="no-logs-message">No log events found for this page.</p>
    {% else %}
        {% for event in display_events %}
            <article class="log-entry">
                <header class="log-entry-header">
                    <h3 class="app-name">{{ event.application_name }}</h3>
                    <p class="window-title"><strong>Window:</strong> {{ event.initial_window_title }}</p>
                </header>
                <section class="log-entry-details">
                    <p><strong>Client ID:</strong> <span class="monospace">{{ event.client_id_str }}</span></p>
                    <p><strong>Schema:</strong> v{{ event.schema_version }}</p>
                    <p><strong>Session:</strong> {{ event.session_start_str }} → {{ event.session_end_str }} UTC</p>
                </section>

                {% if !event.typed_text.is_empty() %}
                <section class="log-data typed-text-section">
                    <h4>Typed Text:</h4>
                    <pre class="typed-text-content monospace">{{ event.typed_text }}</pre>
                </section>
                {% endif %}

                {% if !event.clipboard_actions.is_empty() %}
                <section class="log-data clipboard-section">
                    <h4>Clipboard Actions ({{ event.clipboard_actions.len() }}):</h4>
                    <ul class="clipboard-list">
                        {% for clip in event.clipboard_actions %}
                            <li>
                                <span class="clip-time">{{ clip.timestamp_str }}</span>:
                                <em class="clip-preview">{{ clip.content_preview }}</em>
                                <span class="clip-meta"> ({{ clip.char_count }} chars, hash: <span class="monospace">{{ clip.content_hash_short }}</span>...)</span>
                            </li>
                        {% endfor %}
                    </ul>
                </section>
                {% endif %}
                <footer class="log-entry-footer">
                    <p class="event-meta"><em>Log ID: <span class="monospace">{{ event.id_str }}</span>, Logged (Session Start): {{ event.log_timestamp_str }} UTC</em></p>
                </footer>
            </article>
        {% endfor %}
    {% endif %}
    </div>

    {% if total_pages > 1 %}
    <nav class="pagination">
        {% if current_page > 1 %}
            <a href="/logs?page={{ current_page - 1 }}&page_size={{ page_size }}" class="pagination-link prev">« Previous</a>
        {% else %}
            <span class="pagination-link disabled prev">« Previous</span>
        {% endif %}

        {# Basic pagination display - could be expanded to show more page numbers #}
        {# For simplicity, just showing current page and total #}
        <span class="page-info">Page {{ current_page }} of {{ total_pages }}</span>

        {% if current_page < total_pages %}
            <a href="/logs?page={{ current_page + 1 }}&page_size={{ page_size }}" class="pagination-link next">Next »</a>
        {% else %}
            <span class="pagination-link disabled next">Next »</span>
        {% endif %}
    </nav>
    {% endif %}
{% endblock %}
'''
'''--- activity_generator_gui/src/errors.rs ---
// src/errors.rs (for activity_generator_gui)
use thiserror::Error;

#[derive(Error, Debug)]
pub enum GeneratorError {
    #[error("I/O Error: {source}")]
    Io { #[from] source: std::io::Error },

    #[error("TOML Serialization Error: {source}")]
    TomlSer { #[from] source: toml::ser::Error },

    // If you were to use JSON for server config and deserialize it:
    // #[error("JSON Serialization Error: {source}")]
    // JsonSer { #[from] source: serde_json::Error },
    // #[error("JSON Deserialization Error: {0}")]
    // JsonDe(String),

    #[error("Input not provided or invalid: {field}: {message}")]
    InputValidation { field: String, message: String },

    #[error("File or path operation error: {0}")]
    PathError(String),

    #[error("A required bundled binary template was not found: {binary_name} at path {path_searched}")]
    BinaryTemplateNotFound { binary_name: String, path_searched: String },

    #[error("fs_extra Error: {source}")]
    FsExtra { #[from] source: fs_extra::error::Error },

    #[error("Hex Encoding Error (should not happen with internal key gen): {source}")]
    HexEncoding { #[from] source: hex::FromHexError },

    #[error("An unexpected internal error occurred: {0}")]
    Other(String),
}
'''
'''--- activity_generator_gui/src/generator_logic.rs ---
use crate::app_state::GeneratorAppState;
use crate::errors::GeneratorError;
use std::fs;
use std::io::Write; // For writing bytes
use std::path::Path; // For joining paths
use rand::RngCore;
use uuid::Uuid;
use fs_extra::dir as fs_extra_dir; // Not strictly needed if include_dir handles extraction well
use include_dir::{include_dir, Dir};

// Embed the binaries and server assets directly into the generator executable
static CLIENT_TEMPLATE_PAYLOAD: &[u8] = include_bytes!("embedded_assets/client_template_payload.bin");
static SERVER_TEMPLATE_PAYLOAD: &[u8] = include_bytes!("embedded_assets/server_template_payload.bin");
static SERVER_PACKAGE_CONTENT_DIR: Dir<'_> = include_dir!("$CARGO_MANIFEST_DIR/src/embedded_assets/server_package_content");

const CLIENT_TEMPLATE_ORIGINAL_NAME: &str = "activity_monitor_client_template.exe";
const SERVER_TEMPLATE_ORIGINAL_NAME: &str = "local_log_server_template.exe";

pub fn perform_generation(app_state: &mut GeneratorAppState) -> Result<(), GeneratorError> {
    app_state.operation_in_progress = true;
    app_state.status_message = "Starting generation...".to_string();
    app_state.generated_client_id_display = "Generating...".to_string();
    app_state.generated_key_hex_display_snippet = "Generating...".to_string();

    // --- 1. Validate Inputs ---
    let output_dir = app_state.get_output_dir_path().ok_or_else(|| {
        GeneratorError::InputValidation {
            field: "Output Directory".to_string(),
            message: "Output directory is not set.".to_string(),
        }
    })?;

    if app_state.public_server_url_str.is_empty() || 
       (!app_state.public_server_url_str.starts_with("http://") && !app_state.public_server_url_str.starts_with("https://")) {
        app_state.operation_in_progress = false;
        return Err(GeneratorError::InputValidation {
            field: "Public Server URL".to_string(),
            message: "Public Server URL must be a valid HTTP/HTTPS URL (e.g., https://your.domain.com/api/log).".to_string(),
        });
    }
    if !app_state.public_server_url_str.ends_with("/api/log") {
        // Update status but proceed, user might have specific needs
        app_state.status_message = format!(
            "Warning: Public Server URL '{}' does not end with '/api/log'. This is the typical client endpoint.",
            app_state.public_server_url_str
        );
    }

    // Validate server listen address format (basic check)
    if app_state.server_config.listen_address.split(':').count() != 2 {
        app_state.operation_in_progress = false;
        return Err(GeneratorError::InputValidation {
            field: "Server Listen Address".to_string(),
            message: "Format must be IP:PORT (e.g., 0.0.0.0:8090 or 127.0.0.1:8090).".to_string(),
        });
    }

    app_state.status_message = "Inputs validated. Generating key and client ID...".to_string();

    // --- 2. Generate Unique Key and Client ID ---
    let client_id = Uuid::new_v4().to_string();
    let mut encryption_key_bytes = [0u8; 32];
    rand::thread_rng().fill_bytes(&mut encryption_key_bytes);
    let encryption_key_hex = hex::encode(encryption_key_bytes);
    
    app_state.generated_client_id_display = client_id.clone();
    app_state.generated_key_hex_display_snippet = encryption_key_hex.chars().take(8).collect();

    // --- 3. Prepare Configuration Data ---
    app_state.client_config.server_url = app_state.public_server_url_str.clone();
    app_state.client_config.encryption_key_hex = encryption_key_hex.clone();
    app_state.client_config.client_id = client_id.clone();
    
    app_state.server_config.encryption_key_hex = encryption_key_hex.clone();

    if app_state.server_config.listen_address.starts_with("127.0.0.1") && 
       (app_state.public_server_url_str.starts_with("https://") || // If public URL is HTTPS (implies remote)
        app_state.public_server_url_str.starts_with("http://") && !app_state.public_server_url_str.contains("127.0.0.1") && !app_state.public_server_url_str.contains("localhost")) { // or HTTP and not local
        let current_status = app_state.status_message.clone();
        app_state.status_message = format!(
            "{}\nWarning: Server listen_address is '{}' but public URL seems remote. Consider '0.0.0.0:port' for the server to be accessible by a tunnel/proxy.",
            current_status, app_state.server_config.listen_address
        );
    }

    app_state.status_message = format!("Configuration data prepared. {}", app_state.status_message.split('\n').last().unwrap_or(""));

    // --- 4. Create Output Directory and Package Files ---
    fs::create_dir_all(&output_dir)
        .map_err(|e| GeneratorError::Io{ source: e})?;

    // --- Client Package ---
    let client_output_dir = output_dir.join("ActivityMonitorClient_Package");
    fs::create_dir_all(&client_output_dir)?;

    let final_client_exe_name = CLIENT_TEMPLATE_ORIGINAL_NAME.replace("_template", "");
    let final_client_exe_path = client_output_dir.join(&final_client_exe_name);
    let mut client_exe_file = fs::File::create(&final_client_exe_path)?;
    client_exe_file.write_all(CLIENT_TEMPLATE_PAYLOAD)?;
    drop(client_exe_file); // Ensure file is closed
    #[cfg(unix)] // Make executable on Unix if generated there (though templates are .exe)
    {
        use std::os::unix::fs::PermissionsExt;
        fs::set_permissions(&final_client_exe_path, fs::Permissions::from_mode(0o755))?;
    }
    
    let client_toml_content = toml::to_string_pretty(&app_state.client_config)?;
    fs::write(client_output_dir.join("client_settings.toml"), client_toml_content)?;

    // --- Server Package ---
    let server_output_dir = output_dir.join("LocalLogServer_Package");
    fs::create_dir_all(&server_output_dir)?;
    
    let final_server_exe_name = SERVER_TEMPLATE_ORIGINAL_NAME.replace("_template", "");
    let final_server_exe_path = server_output_dir.join(&final_server_exe_name);
    let mut server_exe_file = fs::File::create(&final_server_exe_path)?;
    server_exe_file.write_all(SERVER_TEMPLATE_PAYLOAD)?;
    drop(server_exe_file); // Ensure file is closed
     #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        fs::set_permissions(&final_server_exe_path, fs::Permissions::from_mode(0o755))?;
    }

    let server_toml_content = toml::to_string_pretty(&app_state.server_config)?;
    fs::write(server_output_dir.join("local_server_config.toml"), server_toml_content)?;
    
    // Extract embedded server static assets and templates
    // The SERVER_PACKAGE_CONTENT_DIR contains 'static/' and 'templates/'
    SERVER_PACKAGE_CONTENT_DIR.extract(&server_output_dir)
        .map_err(|e| GeneratorError::PathError(format!("Failed to extract embedded server assets: {}", e)))?;

    // --- Create README ---
    let local_server_ui_host = app_state.server_config.listen_address.split(':').next().unwrap_or("127.0.0.1");
    let local_server_ui_port = app_state.server_config.listen_address.split(':').nth(1).unwrap_or("8090");
    let local_server_ui_access_address = format!("{}:{}", local_server_ui_host.replace("0.0.0.0", "127.0.0.1"), local_server_ui_port);
    
    let public_server_base_url = if let Some(idx) = app_state.public_server_url_str.rfind("/api/log") {
        app_state.public_server_url_str[..idx].to_string()
    } else {
        // If it doesn't end with /api/log, guess the base by removing the last path segment
        Path::new(&app_state.public_server_url_str).parent().unwrap_or_else(|| Path::new(&app_state.public_server_url_str)).to_string_lossy().to_string()
    };

    let readme_content = format!(
        "Activity Monitoring Suite - Generated Packages\n\
        =============================================\n\n\
        This package was generated by the GuiKeyStandalone Generator.\n\n\
        Client ID: {}\n\
        Encryption Key (Hex Snippet): {}...\n\n\
        Instructions:\n\
        ------------\n\n\
        1. Local Log Server (For Your Machine - The Operator):\n\
           - The 'LocalLogServer_Package' directory contains the server application.\n\
           - Run the '{final_server_exe_name}' executable from within this directory.\n\
           - The server is configured to listen on: {server_listen_address}\n\
           - IMPORTANT: For remote clients to connect, this server must be made accessible via the Public Server URL you configured:\n\
             {public_url}\n\
           - This usually requires a tunneling service (like cloudflared, ngrok), a reverse proxy (Nginx, Caddy with HTTPS), or manual port forwarding.\n\
             Your chosen method should forward traffic from the public URL to the server's listening address (e.g., http://{local_server_ui_access_address}).\n\
           - Once the server is running and publicly accessible, the Web UI can be found at: {public_server_base_url}/logs\n\
             (Or locally for testing: http://{local_server_ui_access_address}/logs)\n\
        \n\
        2. Activity Monitor Client (For Distribution to Target Machines):\n\
           - The 'ActivityMonitorClient_Package' directory contains the client application.\n\
           - Distribute the *contents* of this directory (the client executable and its 'client_settings.toml') to the machine(s) you want to monitor.\n\
           - Run the '{final_client_exe_name_str}' on the target machine(s).\n\
           - It will automatically attempt to connect and send data to your server at: {public_url}\n\
        \n\
        Security Considerations:\n\
        - The generated encryption key is vital. Keep it secure.\n\
        - You are responsible for securing the machine running the Local Log Server, especially since it will be exposed (directly or indirectly) to the internet.\n\
        - Ensure you have proper consent and adhere to all relevant privacy laws and ethical guidelines when deploying the client monitor.\n",
        app_state.generated_client_id_display,
        app_state.generated_key_hex_display_snippet,
        final_server_exe_name = final_server_exe_name,
        server_listen_address = app_state.server_config.listen_address,
        public_url = app_state.public_server_url_str,
        local_server_ui_access_address = local_server_ui_access_address,
        public_server_base_url = public_server_base_url,
        final_client_exe_name_str = final_client_exe_name
    );
    fs::write(output_dir.join("README_IMPORTANT_INSTRUCTIONS.txt"), readme_content)?;
    
    app_state.status_message = format!(
        "Success! Packages generated in {}. Client ID: {}. README_IMPORTANT_INSTRUCTIONS.txt created.",
        output_dir.display(),
        app_state.generated_client_id_display
    );
    app_state.operation_in_progress = false;
    Ok(())
}
'''
'''--- activity_generator_gui/src/main.rs ---
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

mod app_state;
mod config_models;
mod errors;
mod generator_logic;

use eframe::{egui, App, Frame};
use rfd::FileDialog; 
use app_state::GeneratorAppState;
use std::io::Write; 

impl App for GeneratorAppState {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut Frame) {
        egui::CentralPanel::default().show(ctx, |ui| {
            ui.style_mut().spacing.item_spacing = egui::vec2(8.0, 6.0); // Increased spacing a bit
            ui.style_mut().spacing.indent = 12.0;
            
            ui.heading("Remote Activity Monitor - Package Generator");
            ui.add_space(6.0);
            ui.label("This tool generates a client package for remote deployment and a server package for the operator.");
            ui.label("The necessary template binaries and server assets are embedded within this generator.");
            ui.hyperlink_to("View Setup & Usage Instructions Online", "https://github.com/RIZAmohammadkhan/GuiKeyStandalone/blob/main/docs/GENERATOR_GUIDE.md"); // Placeholder
            ui.add_space(10.0);

            egui::ScrollArea::vertical()
                .auto_shrink([false, true])
                .max_height(ui.available_height() - 30.0)
                .show(ui, |ui| {
                
                egui::CollapsingHeader::new("🚀 Core Deployment Configuration")
                    .default_open(true)
                    .show(ui, |ui| {
                        ui.add_space(5.0);
                        ui.strong("Step 1: Configure Public Server URL (Client Target)");
                        ui.label("This is the internet-accessible URL that clients will send data to. It typically ends with '/api/log'. You (the operator) are responsible for making your server reachable at this URL (e.g., via a tunnel like Cloudflare or ngrok, or a reverse proxy).");
                        
                        ui.horizontal(|ui| {
                            ui.label("Public Server URL:");
                            ui.add_sized([ui.available_width(), ui.text_style_height(&egui::TextStyle::Body)], 
                                egui::TextEdit::singleline(&mut self.public_server_url_str)
                                    .hint_text("e.g., https://your-tunnel.example.com/api/log"));
                        });
                        ui.add_space(10.0);

                        ui.strong("Step 2: Select Output Directory");
                        ui.label("Choose a folder where the 'ActivityMonitorClient_Package' and 'LocalLogServer_Package' will be saved.");
                        ui.horizontal(|ui|{
                            ui.label("Output Directory:");
                            ui.add_sized([ui.available_width() - 60.0, ui.text_style_height(&egui::TextStyle::Body)], 
                                egui::TextEdit::singleline(&mut self.output_dir_path_str).hint_text("Path to save generated packages"));
                            if ui.button("📂 Select").on_hover_text("Choose Output Directory").clicked() {
                                if let Some(path) = FileDialog::new().pick_folder() {
                                    self.output_dir_path_str = path.to_string_lossy().into_owned();
                                }
                            }
                        });
                        ui.add_space(5.0);
                    });
                
                ui.add_space(8.0);

                egui::CollapsingHeader::new("🖥️ Local Log Server Configuration (Operator's Machine)")
                    .default_open(true)
                    .show(ui, |ui| {
                    ui.add_space(5.0);
                    ui.label("Configure how the server application (in 'LocalLogServer_Package') will run on your (the operator's) machine. Your tunnel/proxy will point to this local address.");
                    ui.add_space(3.0);
                    egui::Grid::new("server_config_grid")
                        .num_columns(2)
                        .spacing([10.0, 5.0])
                        .min_col_width(180.0) // Ensure labels have enough space
                        .show(ui, |ui| {
                        
                        ui.label("Server Listen Address:");
                        ui.add_sized([ui.available_width(), ui.text_style_height(&egui::TextStyle::Body)],
                            egui::TextEdit::singleline(&mut self.server_config.listen_address)
                                .hint_text("e.g., 0.0.0.0:8090 or 127.0.0.1:8090"));
                        ui.end_row();

                        ui.label("Server Database File Name:");
                        ui.add_sized([ui.available_width(), ui.text_style_height(&egui::TextStyle::Body)],
                            egui::TextEdit::singleline(&mut self.server_config.database_path)
                                .hint_text("e.g., activity_logs.sqlite"));
                        ui.end_row();
                        
                        ui.label("Server Log Retention (days):")
                            .on_hover_text("0 for indefinite. How long the server keeps logs in its database.");
                        ui.add(egui::DragValue::new(&mut self.server_config.log_retention_days)
                            .speed(1.0).clamp_range(0..=3650).suffix(" days"));
                        ui.end_row();
                    });
                     ui.add_space(5.0);
                });
                
                ui.add_space(8.0);

                egui::CollapsingHeader::new("📱 Activity Monitor Client Configuration (Remote Machines)")
                    .default_open(false)
                    .show(ui, |ui| {
                    ui.add_space(5.0);
                    ui.label("These settings apply to the client applications (in 'ActivityMonitorClient_Package') that will be deployed remotely.");
                    ui.add_space(3.0);
                    egui::Grid::new("client_config_grid")
                        .num_columns(2)
                        .spacing([10.0, 5.0])
                        .min_col_width(180.0)
                        .show(ui, |ui| {
                        
                        ui.label("Client Autorun Name:");
                        ui.add_sized([ui.available_width(), ui.text_style_height(&egui::TextStyle::Body)],
                            egui::TextEdit::singleline(&mut self.client_config.app_name_for_autorun));
                        ui.end_row();

                        ui.label("Client Cache Retention (days):")
                            .on_hover_text("0 for indefinite. How long client keeps unsent logs if server is unreachable.");
                        ui.add(egui::DragValue::new(&mut self.client_config.local_log_cache_retention_days)
                            .speed(1.0).clamp_range(0..=365).suffix(" days"));
                        ui.end_row();

                        ui.label("Client Sync Interval (sec):");
                        ui.add(egui::DragValue::new(&mut self.client_config.sync_interval)
                            .speed(10.0).clamp_range(10..=86400).suffix(" s"));
                        ui.end_row();

                        // New field for processor_periodic_flush_interval_secs
                        ui.label("Periodic Session Flush (sec):")
                            .on_hover_text("Interval to flush current app activity if no app switch occurs. 0 to disable periodic flush.");
                        ui.add(egui::DragValue::new(&mut self.client_config.processor_periodic_flush_interval_secs)
                            .speed(10.0).clamp_range(0..=7200u64).suffix(" s")); // 0 to disable, up to 2 hours
                        ui.end_row();
                        
                        ui.label("Max Client Log File Size (MB):")
                            .on_hover_text("Max size for client's local cache (activity_data.jsonl). 0 for no limit (not recommended).");
                        let mut max_size_u64 = self.client_config.max_log_file_size_mb.unwrap_or(0);
                        if ui.add(egui::DragValue::new(&mut max_size_u64).speed(1.0).clamp_range(0..=1024).suffix(" MB")).changed() {
                            self.client_config.max_log_file_size_mb = if max_size_u64 == 0 { None } else { Some(max_size_u64) };
                        }
                        ui.end_row();

                        ui.label("Client Internal Log Level:");
                        egui::ComboBox::from_id_source("client_log_level_combo")
                            .selected_text(self.client_config.internal_log_level.to_uppercase())
                            .width(ui.available_width())
                            .show_ui(ui, |ui| {
                                ui.selectable_value(&mut self.client_config.internal_log_level, "trace".to_string(), "Trace");
                                ui.selectable_value(&mut self.client_config.internal_log_level, "debug".to_string(), "Debug");
                                ui.selectable_value(&mut self.client_config.internal_log_level, "info".to_string(), "Info");
                                ui.selectable_value(&mut self.client_config.internal_log_level, "warn".to_string(), "Warn");
                                ui.selectable_value(&mut self.client_config.internal_log_level, "error".to_string(), "Error");
                            });
                        ui.end_row();
                    });
                    ui.add_space(5.0);
                });
                
                ui.add_space(15.0);

                ui.with_layout(egui::Layout::top_down(egui::Align::Center), |ui| {
                    let generate_button = egui::Button::new("📦 Generate Deployment Packages")
                        .min_size(egui::vec2(300.0, 35.0));
                    
                    if ui.add_enabled(!self.operation_in_progress, generate_button)
                        .on_hover_text("Generates client & server packages using embedded templates into the selected Output Directory.")
                        .clicked() {
                        self.operation_in_progress = true;
                        self.status_message = "Starting generation process...".to_string();
                        self.generated_client_id_display = "Generating...".to_string();
                        self.generated_key_hex_display_snippet = "Generating...".to_string();
                        
                        match generator_logic::perform_generation(self) {
                            Ok(_) => { /* Status updated in perform_generation */ }
                            Err(e) => {
                                self.status_message = format!("Error: {}", e);
                                self.operation_in_progress = false; // Ensure flag is reset on error
                            }
                        }
                    }
                });

                ui.add_space(10.0);
                ui.separator();
                ui.add_space(5.0);

                if self.operation_in_progress {
                    ui.horizontal(|ui| {
                        ui.spinner();
                        ui.label(&self.status_message);
                    });
                } else {
                    ui.label("Status:");
                    let mut status_display_text = self.status_message.clone();
                    ui.add(
                        egui::TextEdit::multiline(&mut status_display_text)
                            .desired_rows(3)
                            .desired_width(f32::INFINITY)
                            .interactive(false)
                            .font(egui::TextStyle::Monospace) // For better error formatting
                    );

                    if self.generated_client_id_display != "N/A" && self.generated_client_id_display != "Generating..." {
                        ui.horizontal(|ui|{
                            ui.label("Generated Client ID:");
                            let mut client_id_text = self.generated_client_id_display.clone();
                            ui.add_sized([ui.available_width(), ui.text_style_height(&egui::TextStyle::Body)],
                                egui::TextEdit::singleline(&mut client_id_text).interactive(false).font(egui::TextStyle::Monospace));
                        });
                    }
                    
                    if self.generated_key_hex_display_snippet != "N/A" && self.generated_key_hex_display_snippet != "Generating..." {
                         ui.horizontal(|ui|{
                            ui.label("Generated Key (snippet):");
                            let mut key_snippet_text = format!("{}...", self.generated_key_hex_display_snippet);
                            ui.add_sized([ui.available_width(), ui.text_style_height(&egui::TextStyle::Body)],
                                egui::TextEdit::singleline(&mut key_snippet_text).interactive(false).font(egui::TextStyle::Monospace));
                        });
                    }
                }
            }); 
        });
    }
}

fn calculate_window_size() -> [f32; 2] {
    let width = 720.0; 
    let height = 780.0; 
    [width, height]
}

fn main() -> eframe::Result<()> {
    let default_panic_hook = std::panic::take_hook();
    std::panic::set_hook(Box::new(move |panic_info| {
        eprintln!("Generator GUI Panicked: {:?}", panic_info);
        let log_message = format!("PANIC: {:?}\nTimestamp: {}\n", panic_info, chrono::Local::now().to_rfc3339());
        if let Ok(exe_path) = std::env::current_exe() {
            if let Some(exe_dir) = exe_path.parent() {
                let panic_log_path = exe_dir.join("generator_gui_panic.log");
                if let Ok(mut file) = std::fs::OpenOptions::new().create(true).append(true).open(panic_log_path) {
                    let _ = writeln!(file, "{}", log_message);
                } else {
                     eprintln!("Failed to open/create panic log file for generator GUI.");
                }
            } else {
                eprintln!("Failed to get executable directory for generator GUI panic log.");
            }
        } else {
             eprintln!("Failed to get current executable path for generator GUI panic log.");
        }
        default_panic_hook(panic_info);
    }));
    
    let window_size = calculate_window_size();
    let options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default()
            .with_inner_size(window_size)
            .with_min_inner_size([680.0, 650.0]) 
            .with_resizable(true)
            .with_decorations(true),
        follow_system_theme: true,
        ..Default::default()
    };
    
    eframe::run_native(
        "Remote Activity Monitor - Package Generator (vEmbed)",
        options,
        Box::new(|_cc| Box::new(GeneratorAppState::default())),
    )
}
'''
'''--- activity_monitor_client_core/Cargo.toml ---
[package]
name = "activity_monitor_client_core"
version = "0.1.0"
edition = "2024"

[dependencies]
tokio = { version = "1", features = ["full"] }
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.7.0", features = ["v4", "serde"] } # Ensure consistent version
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
config = { version = "0.13", features = ["toml"] }
thiserror = "1.0"
tracing = "0.1"
async-stream = "0.3" # ADDED for log_store periodic cleanup timer
tracing-subscriber = { version = "0.3", features = ["env-filter", "fmt"] }
tracing-appender = "0.2" # For file logging
windows-sys = { version = "0.52.0", features = [ # Using a specific stable version
    "Win32_Foundation",
    "Win32_UI_WindowsAndMessaging",
    "Win32_UI_Input_KeyboardAndMouse",
    "Win32_System_Threading",
    "Win32_System_SystemServices",
    "Win32_System_Diagnostics_ToolHelp",
    "Win32_Storage_FileSystem",
    "Win32_System_Registry",
    "Win32_System_LibraryLoader",
    "Win32_System_DataExchange",
    "Win32_System_Memory",
    "Win32_Graphics_Gdi", # For WNDCLASSW if used (clipboard listener window)
    "Win32_System_Ole",   # For CF_UNICODETEXT
]}
winreg = "0.52" # Easier registry access
aes-gcm = "0.10"
rand = "0.8" # For nonce generation
hex = "0.4.3"  # Ensure consistent version
sha2 = "0.10" # For SHA256 hashing
reqwest = { version = "0.12.2", features = ["json", "rustls-tls"], default-features = false } # Ensure consistent version
futures = "0.3" # For select_all in main.rs if still used, or other future utilities
tempfile = "3.8"

[build-dependencies]
embed-manifest = "1.4.0" # Ensure consistent version
'''
'''--- activity_monitor_client_core/build.rs ---
// build.rs
extern crate embed_manifest;

fn main() {
    if std::env::var_os("CARGO_CFG_WINDOWS").is_some() {
        embed_manifest::embed_manifest(embed_manifest::new_manifest("App"))
            .expect("unable to embed manifest");
    }
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=App.manifest"); // Ensure rebuild if manifest changes
}
'''
'''--- activity_monitor_client_core/config/client_settings.example.toml ---
# Example configuration for the Activity Monitor Client Core

server_url = "http://127.0.0.1:8090/api/log" # Example: Local server
# encryption_key_hex will be generated by the Generator GUI
# client_id will be generated by the Generator GUI (or server in some models)

sync_interval = 300  # Seconds (e.g., 5 minutes)
retry_interval_on_fail = 60 # Seconds
max_retries_per_batch = 3

# Event Processor settings
processor_periodic_flush_interval_secs = 120 # Seconds (e.g., 2 minutes)

# Local storage settings
log_file_path = "activity_data.log.bin"
# max_log_file_size_mb = 20 # Optional, client currently doesn't enforce hard rotation
max_events_per_sync_batch = 200 # Number of LogEvent (ApplicationActivity blocks) per sync

# Application behavior
app_name_for_autorun = "SystemActivityAgent"
internal_log_level = "info" # trace, debug, info, warn, error
internal_log_file_dir = "diag_logs_client"
internal_log_file_name = "client_monitor_diag.log"

# This might be used by the client if the generator doesn't explicitly set client_id in the TOML
# client_id_file = "client_identity.txt"

# New (for future implementation in client's LogStore)
local_log_cache_retention_days = 7 # How long to keep unsent logs locally before deleting them
'''
'''--- activity_monitor_client_core/config/client_settings.toml ---
# Example configuration for the Activity Monitor Client Core

server_url = "http://127.0.0.1:8000/api/log" # Example: Local server
# encryption_key_hex will be generated by the Generator GUI
# client_id will be generated by the Generator GUI (or server in some models)
encryption_key_hex = "5aa16c3f4b481bb36cf9f2d69d3266871f2c7e9560761fa8aabcc46f0f33823a"
sync_interval = 30  # Seconds (e.g., 5 minutes)
retry_interval_on_fail = 60 # Seconds
max_retries_per_batch = 3

# Event Processor settings
processor_periodic_flush_interval_secs = 120 # Seconds (e.g., 2 minutes)

# Local storage settings
log_file_path = "activity_data.log.bin"
# max_log_file_size_mb = 20 # Optional, client currently doesn't enforce hard rotation
max_events_per_sync_batch = 200 # Number of LogEvent (ApplicationActivity blocks) per sync

# Application behavior
app_name_for_autorun = "SystemActivityAgent"
internal_log_level = "info" # trace, debug, info, warn, error
internal_log_file_dir = "diag_logs_client"
internal_log_file_name = "client_monitor_diag.log"

# This might be used by the client if the generator doesn't explicitly set client_id in the TOML
# client_id_file = ""

# New (for future implementation in client's LogStore)
local_log_cache_retention_days = 7 # How long to keep unsent logs locally before deleting them
'''
'''--- activity_monitor_client_core/src/app_config.rs ---
use crate::errors::AppError;
use config::{Config, Environment, File as ConfigFile}; // Renamed File to avoid conflict
use serde::Deserialize;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use uuid::Uuid;

// The main Settings struct used throughout the application
#[derive(Debug, Clone)] // Removed Deserialize as we build this from RawSettings
pub struct Settings {
    pub server_url: String,
    pub encryption_key: [u8; 32], // Decoded binary key
    pub client_id: Uuid,           // Loaded or generated

    pub sync_interval: u64,          // seconds
    pub retry_interval_on_fail: u64, // seconds
    pub max_retries_per_batch: u32,

    pub processor_periodic_flush_interval_secs: u64, // seconds

    pub log_file_path: PathBuf, // Path for activity_data.log.bin
    pub max_log_file_size_mb: Option<u64>,
    pub max_events_per_sync_batch: usize, // Number of ApplicationActivity blocks

    pub app_name_for_autorun: String,
    pub internal_log_level: String,
    pub internal_log_file_dir: PathBuf, // Path for diagnostic logs
    pub internal_log_file_name: String,

    // Path to the file where client_id might be persisted (optional)
    pub client_id_file_path: Option<PathBuf>,
    pub local_log_cache_retention_days: u32,
}

// Struct to directly deserialize from client_settings.toml
#[derive(Debug, Deserialize)]
struct RawSettings {
    server_url: String,
    encryption_key_hex: String, // Key as hex string from TOML
    client_id: Option<String>,  // Client ID might be directly in TOML

    sync_interval: u64,
    retry_interval_on_fail: u64,
    max_retries_per_batch: u32,

    processor_periodic_flush_interval_secs: u64,

    log_file_path: String,
    max_log_file_size_mb: Option<u64>,
    max_events_per_sync_batch: usize,

    app_name_for_autorun: String,
    internal_log_level: String,
    internal_log_file_dir: String,
    internal_log_file_name: String,

    client_id_file: Option<String>, // Path to file for persisting client_id
    local_log_cache_retention_days: Option<u32>, // Optional in TOML, with default
}

impl Settings {
    pub fn new() -> Result<Arc<Self>, AppError> {
        // Determine config path:
        // 1. Try executable_dir/config/client_settings.toml
        // 2. Try executable_dir/client_settings.toml
        // 3. Try current_dir/config/client_settings.toml (for dev)
        // 4. Try current_dir/client_settings.toml (for dev)

        let exe_path = std::env::current_exe()
            .map_err(|e| AppError::Config(format!("Failed to get current exe path: {}", e)))?;
        let exe_dir = exe_path.parent()
            .ok_or_else(|| AppError::Config("Failed to get parent directory of executable.".to_string()))?;

        let config_paths_to_try = [
            exe_dir.join("config").join("client_settings.toml"),
            exe_dir.join("client_settings.toml"),
            PathBuf::from("config").join("client_settings.toml"), // Relative to CWD
            PathBuf::from("client_settings.toml"),                // Relative to CWD
        ];

        let mut config_builder = Config::builder();
        let mut loaded_from_file = false;

        for path_to_try in &config_paths_to_try {
            if path_to_try.exists() {
                config_builder = config_builder.add_source(ConfigFile::from(path_to_try.clone()).required(true));
                loaded_from_file = true;
                println!("[INFO] Loading configuration from: {:?}", path_to_try); // Temporary println
                break;
            }
        }

        if !loaded_from_file {
            return Err(AppError::Config(
                "client_settings.toml not found in standard locations.".to_string(),
            ));
        }

        // Add environment variable overrides
        config_builder = config_builder.add_source(
            Environment::with_prefix("AMS_CLIENT") // Activity Monitor Suite Client
                .separator("__")
                .try_parsing(true), // Attempt to parse strings to target types
        );

        let raw_settings: RawSettings = config_builder
            .build()
            .map_err(|e| AppError::Config(format!("Failed to build configuration: {}", e)))?
            .try_deserialize()
            .map_err(|e| AppError::Config(format!("Failed to deserialize configuration: {}", e)))?;

        // Process encryption key
        let key_bytes = hex::decode(&raw_settings.encryption_key_hex)
            .map_err(AppError::HexDecode)?;
        if key_bytes.len() != 32 {
            return Err(AppError::Config(
                "Encryption key must be 32 bytes (64 hex characters).".to_string(),
            ));
        }
        let mut encryption_key = [0u8; 32];
        encryption_key.copy_from_slice(&key_bytes);

        // Determine client_id_file_path
        let client_id_file_path = raw_settings.client_id_file.as_ref().map(PathBuf::from);

        // Load or generate client_id
        // Priority: 1. Direct from TOML, 2. From client_id_file, 3. Generate new
        let client_id = if let Some(id_str) = raw_settings.client_id {
            Uuid::parse_str(&id_str)
                .map_err(|e| AppError::Config(format!("Invalid client_id in TOML: {}", e)))?
        } else {
            load_or_generate_client_id(client_id_file_path.as_deref())?
        };

        // Construct the final Settings struct
        Ok(Arc::new(Settings {
            server_url: raw_settings.server_url,
            encryption_key,
            client_id,
            sync_interval: raw_settings.sync_interval,
            retry_interval_on_fail: raw_settings.retry_interval_on_fail,
            max_retries_per_batch: raw_settings.max_retries_per_batch,
            processor_periodic_flush_interval_secs: raw_settings.processor_periodic_flush_interval_secs,
            log_file_path: exe_dir.join(raw_settings.log_file_path), // Make relative to exe dir
            max_log_file_size_mb: raw_settings.max_log_file_size_mb,
            max_events_per_sync_batch: raw_settings.max_events_per_sync_batch,
            app_name_for_autorun: raw_settings.app_name_for_autorun,
            internal_log_level: raw_settings.internal_log_level,
            internal_log_file_dir: exe_dir.join(raw_settings.internal_log_file_dir), // Make relative to exe dir
            internal_log_file_name: raw_settings.internal_log_file_name,
            client_id_file_path,
            local_log_cache_retention_days: raw_settings.local_log_cache_retention_days.unwrap_or(7), // Default if not in TOML
        }))
    }
}

// Helper function to load client_id from a file or generate a new one
fn load_or_generate_client_id(path_opt: Option<&Path>) -> Result<Uuid, AppError> {
    if let Some(p) = path_opt {
        // Ensure path is absolute or resolve relative to exe_dir if needed
        // For simplicity, assuming if client_id_file is specified, it's an intended path
        let file_path = if p.is_absolute() {
            p.to_path_buf()
        } else {
            // If relative, make it relative to the executable's directory
            let exe_dir = std::env::current_exe()
                .ok().and_then(|p| p.parent().map(|p| p.to_path_buf()))
                .ok_or_else(|| AppError::Config("Cannot determine executable directory for relative client_id_file path.".to_string()))?;
            exe_dir.join(p)
        };

        if file_path.exists() {
            let id_str = std::fs::read_to_string(&file_path)
                .map_err(|e| AppError::Io(e))?; // Map IO error to AppError
            return Uuid::parse_str(id_str.trim())
                .map_err(|e| AppError::Config(format!("Invalid client_id in file {:?}: {}", file_path, e)));
        }
    }

    // Generate new ID
    let new_id = Uuid::new_v4();
    tracing::info!("Generated new client_id: {}", new_id); // Use tracing, but logger might not be init yet

    // Attempt to save if path was provided
    if let Some(p) = path_opt {
        let file_path = if p.is_absolute() {
            p.to_path_buf()
        } else {
            let exe_dir = std::env::current_exe()
                .ok().and_then(|p| p.parent().map(|p| p.to_path_buf()))
                .ok_or_else(|| AppError::Config("Cannot determine executable directory for relative client_id_file path.".to_string()))?;
            exe_dir.join(p)
        };

        if let Some(parent_dir) = file_path.parent() {
            std::fs::create_dir_all(parent_dir).map_err(|e| AppError::Io(e))?;
        }
        std::fs::write(&file_path, new_id.to_string()).map_err(|e| AppError::Io(e))?;
        // Use println here as tracing might not be initialized when config is first loaded
        println!("[INFO] Generated and saved new client_id: {} to {:?}", new_id, file_path);
    } else {
         println!("[INFO] Generated new client_id for this session (no client_id_file configured): {}", new_id);
    }
    Ok(new_id)
}
'''
'''--- activity_monitor_client_core/src/core_monitors/clipboard_capture.rs ---
// src/core_monitors/clipboard_capture.rs
use crate::app_config::Settings;
use crate::errors::{AppError, win_api_error};
use crate::core_monitors::foreground_app::get_current_foreground_app_info_sync;
use std::ptr::{null, null_mut};
use std::sync::{mpsc as std_mpsc, Arc};
use std::thread;

use windows_sys::Win32::Foundation::{
    GetLastError, LPARAM, LRESULT, WPARAM, HWND, FALSE, HMODULE, HGLOBAL,
    ERROR_CLASS_ALREADY_EXISTS, ERROR_CLASS_DOES_NOT_EXIST, // Using these from windows_sys
};
use windows_sys::Win32::UI::WindowsAndMessaging::{
    WNDCLASSW, CreateWindowExW, DefWindowProcW, DestroyWindow, GetMessageW, HMENU,
    DispatchMessageW, PeekMessageW, PostQuitMessage, RegisterClassW, UnregisterClassW,
    TranslateMessage,
    MSG, PM_NOREMOVE, CW_USEDEFAULT, HWND_MESSAGE, WM_CLIPBOARDUPDATE, WM_DESTROY,
};
use windows_sys::Win32::System::LibraryLoader::GetModuleHandleW;
use windows_sys::Win32::System::Memory::{GlobalLock, GlobalUnlock, GlobalSize};
use windows_sys::Win32::System::DataExchange::{
    OpenClipboard, CloseClipboard, GetClipboardData,
    AddClipboardFormatListener, RemoveClipboardFormatListener,
};
use windows_sys::Win32::System::Ole::CF_UNICODETEXT;

const CLIPBOARD_LISTENER_CLASS_NAME_WSTR: &[u16] = &[
    0x0043, 0x006C, 0x0069, 0x0070, 0x0062, 0x006F, 0x0061, 0x0072, 0x0064,
    0x004C, 0x0069, 0x0073, 0x0074, 0x0065, 0x006E, 0x0065, 0x0072, 0x0052,
    0x0075, 0x0073, 0x0074, 0x0000,
];

#[derive(Debug, Clone)]
pub struct RawClipboardData {
    pub text_content: String,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub foreground_app_name: String,
    pub foreground_window_title: String,
}

static mut EVENT_SENDER_CLIPBOARD: Option<std_mpsc::Sender<RawClipboardData>> = None;
static mut CLIPBOARD_HWND_STATIC: HWND = 0 as HWND;

struct ClipboardWindowResources {
    hwnd: HWND,
    h_instance: HMODULE,
    class_name_ptr: *const u16,
}

const LOCAL_ERROR_CANNOT_UNREGISTER_ONLINE_CLASS: u32 = 1431;

impl Drop for ClipboardWindowResources {
    fn drop(&mut self) {
        unsafe {
            if self.hwnd != (0 as HWND) {
                RemoveClipboardFormatListener(self.hwnd);
                DestroyWindow(self.hwnd);
                CLIPBOARD_HWND_STATIC = 0 as HWND;
            }
            if UnregisterClassW(self.class_name_ptr, self.h_instance) == FALSE {
                let err = GetLastError();
                if err != ERROR_CLASS_DOES_NOT_EXIST && err != LOCAL_ERROR_CANNOT_UNREGISTER_ONLINE_CLASS {
                    eprintln!("[ERROR] Failed to unregister clipboard listener window class (Error: {}): {}", err, win_api_error("UnregisterClassW (clipboard)").to_string());
                }
            } else {
                // eprintln!("[INFO] Clipboard listener window class unregistered.");
            }
        }
    }
}

pub fn start_clipboard_monitoring(
    event_tx: std_mpsc::Sender<RawClipboardData>,
    _settings: Arc<Settings>,
) -> Result<thread::JoinHandle<()>, AppError> {
    println!("[INFO] Initializing clipboard monitor...");
    unsafe {
        EVENT_SENDER_CLIPBOARD = Some(event_tx);
    }

    let handle = thread::Builder::new()
        .name("clipboard_monitor_thread".to_string())
        .spawn(move || unsafe {
            let h_instance_handle = GetModuleHandleW(null_mut());
            if h_instance_handle == 0 {
                eprintln!("[ERROR] Clipboard GetModuleHandleW failed: {}", win_api_error("GetModuleHandleW (clipboard)").to_string());
                return;
            }
            let h_module_instance = h_instance_handle as HMODULE;

            let mut wc: WNDCLASSW = std::mem::zeroed();
            wc.lpfnWndProc = Some(clipboard_window_proc);
            wc.hInstance = h_module_instance;
            wc.lpszClassName = CLIPBOARD_LISTENER_CLASS_NAME_WSTR.as_ptr();

            if RegisterClassW(&wc) == 0 {
                let err = GetLastError();
                if err != ERROR_CLASS_ALREADY_EXISTS {
                    eprintln!("[ERROR] RegisterClassW for clipboard failed (Error: {}): {}", err, win_api_error("RegisterClassW (clipboard)").to_string());
                    return;
                }
            }

            let hwnd = CreateWindowExW(
                0,
                CLIPBOARD_LISTENER_CLASS_NAME_WSTR.as_ptr(),
                null(),
                0,
                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                HWND_MESSAGE,
                0 as HMENU,
                h_module_instance,
                null_mut(),
            );

            if hwnd == (0 as HWND) {
                eprintln!("[ERROR] CreateWindowExW for clipboard failed: {}", win_api_error("CreateWindowExW (clipboard)").to_string());
                return;
            }
            CLIPBOARD_HWND_STATIC = hwnd;
            println!("[INFO] Clipboard listener window created. HWND: {:?}", hwnd);

            let _window_resources_guard = ClipboardWindowResources {
                hwnd,
                h_instance: h_module_instance,
                class_name_ptr: CLIPBOARD_LISTENER_CLASS_NAME_WSTR.as_ptr(),
            };

            if AddClipboardFormatListener(hwnd) == FALSE {
                eprintln!("[ERROR] AddClipboardFormatListener failed: {}", win_api_error("AddClipboardFormatListener").to_string());
                return;
            }
            println!("[INFO] AddClipboardFormatListener succeeded.");

            let mut msg: MSG = std::mem::zeroed();
            while GetMessageW(&mut msg, hwnd, 0, 0) > 0 {
                TranslateMessage(&msg);
                DispatchMessageW(&msg);
            }
            println!("[INFO] Clipboard monitor message loop ended.");
        })
        .map_err(|e| AppError::Hook(format!("Failed to spawn clipboard monitor thread: {}", e)))?;
    Ok(handle)
}

unsafe extern "system" fn clipboard_window_proc(
    hwnd: HWND,
    msg: u32,
    w_param: WPARAM,
    l_param: LPARAM,
) -> LRESULT {
    match msg {
        WM_CLIPBOARDUPDATE => {
            if OpenClipboard(hwnd) != FALSE {
                // CORRECTED: Cast CF_UNICODETEXT to u32
                let h_data_handle = GetClipboardData(CF_UNICODETEXT as u32);
                if h_data_handle != 0 {
                    let h_global_data = h_data_handle as HGLOBAL;
                    let p_data_raw = GlobalLock(h_global_data);
                    if !p_data_raw.is_null() {
                        let p_data = p_data_raw as *const u16;
                        let data_size_bytes = GlobalSize(h_global_data);
                        let mut len = 0;
                        if data_size_bytes > 0 {
                            let max_chars = (data_size_bytes / std::mem::size_of::<u16>()) as usize;
                            len = max_chars;
                            for i in 0..max_chars {
                                if *p_data.add(i) == 0 {
                                    len = i;
                                    break;
                                }
                            }
                        }

                        if len > 0 {
                            let slice = std::slice::from_raw_parts(p_data, len);
                            let text_content = String::from_utf16_lossy(slice);

                            let sender_option_ptr: *const Option<std_mpsc::Sender<RawClipboardData>> =
                                core::ptr::addr_of!(EVENT_SENDER_CLIPBOARD);

                            if let Some(ref sender_in_option) = *sender_option_ptr {
                                let sender_clone = sender_in_option.clone();
                                let app_info = get_current_foreground_app_info_sync();
                                let raw_event = RawClipboardData {
                                    text_content,
                                    timestamp: chrono::Utc::now(),
                                    foreground_app_name: app_info.executable_name,
                                    foreground_window_title: app_info.title,
                                };
                                if let Err(e) = sender_clone.send(raw_event) {
                                    eprintln!("[ERROR] Failed to send raw clipboard event: {}", e.to_string());
                                }
                            }
                        }
                        GlobalUnlock(h_global_data);
                    }
                }
                CloseClipboard();
            }
            0
        }
        WM_DESTROY => {
            PostQuitMessage(0);
            0
        }
        _ => DefWindowProcW(hwnd, msg, w_param, l_param),
    }
}
'''
'''--- activity_monitor_client_core/src/core_monitors/foreground_app.rs ---
// src/core_monitors/foreground_app.rs

use windows_sys::Win32::{
    Foundation::{CloseHandle, MAX_PATH, HANDLE}, // GetLastError is in Foundation
    System::{
        Diagnostics::ToolHelp::{
            CreateToolhelp32Snapshot, Process32FirstW, Process32NextW, PROCESSENTRY32W, TH32CS_SNAPPROCESS,
        },
        Threading::{OpenProcess, QueryFullProcessImageNameW, PROCESS_QUERY_LIMITED_INFORMATION, PROCESS_VM_READ},
    },
    UI::WindowsAndMessaging::{GetForegroundWindow, GetWindowTextW, GetWindowThreadProcessId},
};
use std::ptr::null_mut; // For GetModuleHandleW in other files

#[derive(Debug, Clone, Default)]
pub struct ForegroundAppInfo {
    pub title: String,
    pub executable_name: String,
    pub process_id: u32,
    pub thread_id: u32, // Main thread ID of the foreground window
}

pub fn get_current_foreground_app_info_sync() -> ForegroundAppInfo {
    let mut info = ForegroundAppInfo::default();
    unsafe {
        let hwnd = GetForegroundWindow();
        if hwnd == 0 { // 0 is an invalid HWND
            // tracing::trace!("GetForegroundWindow returned null, no active window.");
            return info;
        }

        let mut window_title_buffer: [u16; 512] = [0; 512];
        let title_length = GetWindowTextW(hwnd, window_title_buffer.as_mut_ptr(), 512);
        if title_length > 0 {
            info.title = String::from_utf16_lossy(&window_title_buffer[..title_length as usize]);
        } else {
            // tracing::trace!("GetWindowTextW failed or returned empty title for HWND {:?}", hwnd);
        }

        info.thread_id = GetWindowThreadProcessId(hwnd, &mut info.process_id);

        if info.process_id != 0 {
            // PROCESS_QUERY_LIMITED_INFORMATION is generally safer and requires fewer privileges
            // than PROCESS_QUERY_INFORMATION. PROCESS_VM_READ might be needed for some fallbacks but try without first.
            let h_process = OpenProcess(
                PROCESS_QUERY_LIMITED_INFORMATION, // Try with fewer permissions first
                0, // FALSE for bInheritHandle
                info.process_id,
            );

            if h_process != 0 && h_process != -1isize { // Valid process handle
                let mut exe_path_buffer: [u16; MAX_PATH as usize] = [0; MAX_PATH as usize];
                let mut exe_path_len = MAX_PATH; // Needs to be u32
                if QueryFullProcessImageNameW(
                    h_process,
                    0, // Can be 0 for default format or PROCESS_NAME_NATIVE
                    exe_path_buffer.as_mut_ptr(),
                    &mut exe_path_len, // Pass as mutable reference
                ) != 0 { // Non-zero means success
                    let exe_path_actual_len = exe_path_buffer.iter().position(|&c| c == 0).unwrap_or(exe_path_len as usize);
                    let exe_path = String::from_utf16_lossy(&exe_path_buffer[..exe_path_actual_len]);
                    if let Some(name) = exe_path.rsplit('\\').next() {
                        info.executable_name = name.to_string();
                    } else {
                        info.executable_name = exe_path; // Should not happen if path is valid
                    }
                } else {
                    // Fallback if QueryFullProcessImageNameW fails (e.g., access denied for some processes)
                    // tracing::debug!("QueryFullProcessImageNameW failed for PID {}: Error code {}. Using fallback.", info.process_id, windows_sys::Win32::Foundation::GetLastError());
                    info.executable_name = get_process_name_fallback(info.process_id).unwrap_or_else(|| "unknown.exe".to_string());
                }
                CloseHandle(h_process);
            } else {
                // Fallback if OpenProcess fails
                // tracing::debug!("OpenProcess failed for PID {}: Error code {}. Using fallback.", info.process_id, windows_sys::Win32::Foundation::GetLastError());
                info.executable_name = get_process_name_fallback(info.process_id).unwrap_or_else(|| "unknown.exe".to_string());
            }
        }
    }
    info
}

// Fallback using ToolHelp snapshot
fn get_process_name_fallback(pid: u32) -> Option<String> {
    unsafe {
        let snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if snapshot == -1isize as HANDLE { // INVALID_HANDLE_VALUE
            return None;
        }

        let mut pe32: PROCESSENTRY32W = std::mem::zeroed();
        pe32.dwSize = std::mem::size_of::<PROCESSENTRY32W>() as u32;

        if Process32FirstW(snapshot, &mut pe32) == 0 { // FALSE
            CloseHandle(snapshot);
            return None;
        }

        loop {
            if pe32.th32ProcessID == pid {
                let exe_file_null_term_idx = pe32.szExeFile.iter().position(|&c| c == 0).unwrap_or(pe32.szExeFile.len());
                let name = String::from_utf16_lossy(&pe32.szExeFile[..exe_file_null_term_idx]);
                CloseHandle(snapshot);
                return Some(name);
            }
            if Process32NextW(snapshot, &mut pe32) == 0 { // FALSE
                break;
            }
        }
        CloseHandle(snapshot);
    }
    None
}
'''
'''--- activity_monitor_client_core/src/core_monitors/keyboard_capture.rs ---
use crate::errors::{AppError, win_api_error};
use crate::core_monitors::foreground_app::get_current_foreground_app_info_sync;
use crate::core_monitors::vk_utils;
use std::ptr::{null_mut};
use std::sync::{mpsc as std_mpsc};
use std::thread;

use windows_sys::Win32::Foundation::{LPARAM, LRESULT, WPARAM, FALSE, HMODULE, HWND};
use windows_sys::Win32::UI::WindowsAndMessaging::{
    SetWindowsHookExW, UnhookWindowsHookEx, CallNextHookEx,
    WH_KEYBOARD_LL, HC_ACTION, HHOOK, KBDLLHOOKSTRUCT,
    GetMessageW, TranslateMessage, DispatchMessageW, PeekMessageW,
    MSG, PM_NOREMOVE,
};
use windows_sys::Win32::System::LibraryLoader::GetModuleHandleW;

// Ensure this struct is correctly named RawKeyboardData
#[derive(Debug, Clone)]
pub struct RawKeyboardData { // <<<<------ CORRECT NAME HERE
    pub vk_code: u16,
    pub scan_code: u32,
    pub flags: u32,
    pub key_value: String,
    pub is_char: bool,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub foreground_app_name: String,
    pub foreground_window_title: String,
}

static mut EVENT_SENDER_KEYBOARD: Option<std_mpsc::Sender<RawKeyboardData>> = None;
static mut HOOK_HANDLE_KEYBOARD: HHOOK = 0 as HHOOK;

struct KeyboardHookHandleRAII(HHOOK);
impl Drop for KeyboardHookHandleRAII {
    fn drop(&mut self) {
        if self.0 != (0 as HHOOK) {
            unsafe {
                if UnhookWindowsHookEx(self.0) == FALSE {
                    eprintln!("[ERROR] Failed to unhook keyboard: {}", win_api_error("UnhookWindowsHookEx (keyboard)").to_string());
                } else {
                    // eprintln!("[INFO] Keyboard hook unhooked successfully.");
                }
                HOOK_HANDLE_KEYBOARD = 0 as HHOOK;
            }
        }
    }
}

// Ensure this function is correctly named start_keyboard_monitoring
pub fn start_keyboard_monitoring( // <<<<------ CORRECT NAME HERE
    event_tx: std_mpsc::Sender<RawKeyboardData> // <<<<------ Parameter type should be RawKeyboardData
) -> Result<thread::JoinHandle<()>, AppError> {
    println!("[INFO] Initializing keyboard monitor...");
    unsafe {
        EVENT_SENDER_KEYBOARD = Some(event_tx);
    }

    let handle = thread::Builder::new()
        .name("keyboard_hook_thread".to_string())
        .spawn(move || {
            let h_instance_handle = unsafe { GetModuleHandleW(null_mut()) };
            if h_instance_handle == 0 {
                eprintln!("[ERROR] Keyboard hook GetModuleHandleW failed: {}", win_api_error("GetModuleHandleW (keyboard)").to_string());
                return;
            }
            let h_instance = h_instance_handle as HMODULE;

            let hook_handle = unsafe {
                SetWindowsHookExW(WH_KEYBOARD_LL, Some(keyboard_hook_proc), h_instance, 0)
            };

            if hook_handle == (0 as HHOOK) {
                eprintln!("[ERROR] SetWindowsHookExW for keyboard failed: {}", win_api_error("SetWindowsHookExW (keyboard)").to_string());
                return;
            }
            unsafe { HOOK_HANDLE_KEYBOARD = hook_handle };
            println!("[INFO] Keyboard hook set successfully. Handle: {:?}", hook_handle);
            let _hook_guard = KeyboardHookHandleRAII(hook_handle);

            let mut msg: MSG = unsafe { std::mem::zeroed() };
            unsafe {
                PeekMessageW(&mut msg, 0 as HWND, 0, 0, PM_NOREMOVE);
                while GetMessageW(&mut msg, 0 as HWND, 0, 0) > 0 {
                    TranslateMessage(&msg);
                    DispatchMessageW(&msg);
                }
            }
            println!("[INFO] Keyboard hook message loop ended.");
        })
        .map_err(|e| AppError::Hook(format!("Failed to spawn keyboard hook thread: {}", e)))?;

    Ok(handle)
}

unsafe extern "system" fn keyboard_hook_proc(n_code: i32, w_param: WPARAM, l_param: LPARAM) -> LRESULT {
    if n_code == HC_ACTION as i32 {
        let kbd_struct_ptr = l_param as *const KBDLLHOOKSTRUCT;
        if kbd_struct_ptr.is_null() {
             return CallNextHookEx(HOOK_HANDLE_KEYBOARD, n_code, w_param, l_param);
        }
        let kbd_struct = *kbd_struct_ptr;
        
        let (key_value, is_char) = vk_utils::vk_code_to_string(
            kbd_struct.vkCode as u16,
            kbd_struct.scanCode,
            kbd_struct.flags
        );

        let app_info = get_current_foreground_app_info_sync();

        let raw_event = RawKeyboardData { // <<<<------ Ensure this is RawKeyboardData
            vk_code: kbd_struct.vkCode as u16,
            scan_code: kbd_struct.scanCode,
            flags: kbd_struct.flags,
            key_value,
            is_char,
            timestamp: chrono::Utc::now(),
            foreground_app_name: app_info.executable_name,
            foreground_window_title: app_info.title,
        };

        let sender_option_ptr: *const Option<std_mpsc::Sender<RawKeyboardData>> = 
            core::ptr::addr_of!(EVENT_SENDER_KEYBOARD);

        if let Some(ref sender_in_option) = *sender_option_ptr {
            let sender_clone = sender_in_option.clone();
            if let Err(e) = sender_clone.send(raw_event) {
                eprintln!("[ERROR] Failed to send raw keyboard event: {}", e.to_string());
            }
        }
    }
    CallNextHookEx(HOOK_HANDLE_KEYBOARD, n_code, w_param, l_param)
}
'''
'''--- activity_monitor_client_core/src/core_monitors/mod.rs ---
// src/core_monitors/mod.rs

pub mod foreground_app;
pub mod keyboard_capture;
pub mod clipboard_capture;
mod vk_utils; // Keep vk_utils private to the core_monitors module (helper)
'''
'''--- activity_monitor_client_core/src/core_monitors/vk_utils.rs ---
use windows_sys::Win32::UI::WindowsAndMessaging::LLKHF_UP;
use windows_sys::Win32::UI::Input::KeyboardAndMouse::{
    GetKeyboardState, ToUnicode,
    VK_LBUTTON, VK_RBUTTON, VK_MBUTTON, VK_XBUTTON1, VK_XBUTTON2,
    VK_BACK, VK_TAB, VK_CLEAR, VK_RETURN, VK_SHIFT, VK_LSHIFT, VK_RSHIFT,
    VK_CONTROL, VK_LCONTROL, VK_RCONTROL, VK_MENU, VK_LMENU, VK_RMENU,
    VK_PAUSE, VK_CAPITAL, VK_KANA, VK_HANGEUL, VK_HANGUL, VK_JUNJA, VK_FINAL,
    VK_HANJA, VK_KANJI, VK_ESCAPE, VK_CONVERT, VK_NONCONVERT, VK_ACCEPT,
    VK_MODECHANGE, VK_SPACE, VK_PRIOR, VK_NEXT, VK_END, VK_HOME, VK_LEFT,
    VK_UP, VK_RIGHT, VK_DOWN, VK_SELECT, VK_PRINT, VK_EXECUTE, VK_SNAPSHOT,
    VK_INSERT, VK_DELETE, VK_HELP, VK_LWIN, VK_RWIN, VK_APPS, VK_SLEEP,
    VK_NUMPAD0, VK_NUMPAD1, VK_NUMPAD2, VK_NUMPAD3, VK_NUMPAD4, VK_NUMPAD5,
    VK_NUMPAD6, VK_NUMPAD7, VK_NUMPAD8, VK_NUMPAD9,
    VK_MULTIPLY, VK_ADD, VK_SEPARATOR, VK_SUBTRACT, VK_DECIMAL, VK_DIVIDE,
    VK_F1, VK_F2, VK_F3, VK_F4, VK_F5, VK_F6, VK_F7, VK_F8, VK_F9, VK_F10,
    VK_F11, VK_F12, VK_F13, VK_F14, VK_F15, VK_F16, VK_F17, VK_F18, VK_F19,
    VK_F20, VK_F21, VK_F22, VK_F23, VK_F24,
    VK_NUMLOCK, VK_SCROLL,
    VK_BROWSER_BACK, VK_BROWSER_FORWARD, VK_BROWSER_REFRESH, VK_BROWSER_STOP,
    VK_BROWSER_SEARCH, VK_BROWSER_FAVORITES, VK_BROWSER_HOME,
    VK_VOLUME_MUTE, VK_VOLUME_DOWN, VK_VOLUME_UP,
    VK_MEDIA_NEXT_TRACK, VK_MEDIA_PREV_TRACK, VK_MEDIA_STOP, VK_MEDIA_PLAY_PAUSE,
    VK_LAUNCH_MAIL, VK_LAUNCH_MEDIA_SELECT, VK_LAUNCH_APP1, VK_LAUNCH_APP2,
};
// use windows_sys::Win32::UI::WindowsAndMessaging::LLKHF_UP;

pub fn vk_code_to_string(vk_code_u16: u16, scan_code: u32, flags: u32) -> (String, bool) {
    let mut is_char = false;
    let mut buffer: [u16; 8] = [0; 8];
    let mut keyboard_state: [u8; 256] = [0; 256];
    
    // Check if LLKHF_UP is set in flags. LLKHF_UP should be u32.
    let _is_key_up = flags & LLKHF_UP == LLKHF_UP;
    let to_unicode_flags = 0u32; // For ToUnicode, 0 is often sufficient.

    let representation = unsafe {
        if GetKeyboardState(keyboard_state.as_mut_ptr()) == 0 {
            // This tracing call might not be ideal if logger isn't fully up when this is first called
            // Consider a more robust fallback or ensuring logger is always available.
            // For now, simple println if tracing fails, or just proceed to simple_vk_map.
            // tracing::warn!("GetKeyboardState failed in vk_code_to_string");
            return simple_vk_map(vk_code_u16);
        }

        let result = ToUnicode(
            vk_code_u16 as u32,
            scan_code,
            keyboard_state.as_ptr(),
            buffer.as_mut_ptr(),
            buffer.len() as i32,
            to_unicode_flags,
        );

        if result > 0 {
            is_char = true;
            let char_count = result as usize;
            let end = buffer.iter().take(char_count).position(|&c| c == 0).unwrap_or(char_count);
            String::from_utf16_lossy(&buffer[..end])
        } else if result == 0 { // No translation
            is_char = false;
            simple_vk_map(vk_code_u16).0
        } else { // result < 0, dead key. abs(result) is number of chars.
            is_char = true; // Treat as a character for logging purposes
            let char_count = result.abs() as usize;
            let end = buffer.iter().take(char_count).position(|&c| c == 0).unwrap_or(char_count);
            String::from_utf16_lossy(&buffer[..end]) // This will be the dead key char like ` or ~
        }
    };

    (representation, is_char)
}

fn simple_vk_map(vk_code: u16) -> (String, bool) {
    let mut is_char = false;
    let vk_code_i32 = vk_code as i32;

    // Assuming VK_* constants are u16 or directly castable as per your working version
    let representation = match vk_code_i32 {
        c if c == VK_LBUTTON as i32 => "[MOUSE_LBUTTON]".to_string(),
        c if c == VK_RBUTTON as i32 => "[MOUSE_RBUTTON]".to_string(),
        c if c == VK_MBUTTON as i32 => "[MOUSE_MBUTTON]".to_string(),
        c if c == VK_XBUTTON1 as i32 => "[MOUSE_XBUTTON1]".to_string(),
        c if c == VK_XBUTTON2 as i32 => "[MOUSE_XBUTTON2]".to_string(),
        c if c == VK_BACK as i32 => "[BACKSPACE]".to_string(),
        c if c == VK_TAB as i32 => "[TAB]".to_string(),
        c if c == VK_CLEAR as i32 => "[CLEAR]".to_string(),
        c if c == VK_RETURN as i32 => "[ENTER]".to_string(),
        c if c == VK_SHIFT as i32 => "[SHIFT_ANY]".to_string(),
        c if c == VK_LSHIFT as i32 => "[LSHIFT]".to_string(),
        c if c == VK_RSHIFT as i32 => "[RSHIFT]".to_string(),
        c if c == VK_CONTROL as i32 => "[CTRL_ANY]".to_string(),
        c if c == VK_LCONTROL as i32 => "[LCTRL]".to_string(),
        c if c == VK_RCONTROL as i32 => "[RCTRL]".to_string(),
        c if c == VK_MENU as i32 => "[ALT_ANY]".to_string(),
        c if c == VK_LMENU as i32 => "[LALT]".to_string(),
        c if c == VK_RMENU as i32 => "[RALT]".to_string(),
        c if c == VK_PAUSE as i32 => "[PAUSE]".to_string(),
        c if c == VK_CAPITAL as i32 => "[CAPSLOCK]".to_string(),
        c if c == VK_KANA as i32 || c == VK_HANGEUL as i32 || c == VK_HANGUL as i32 => "[KANA/HANGUL]".to_string(),
        c if c == VK_JUNJA as i32 => "[JUNJA]".to_string(),
        c if c == VK_FINAL as i32 => "[FINAL]".to_string(),
        c if c == VK_HANJA as i32 || c == VK_KANJI as i32 => "[HANJA/KANJI]".to_string(),
        c if c == VK_ESCAPE as i32 => "[ESC]".to_string(),
        c if c == VK_CONVERT as i32 => "[CONVERT]".to_string(),
        c if c == VK_NONCONVERT as i32 => "[NONCONVERT]".to_string(),
        c if c == VK_ACCEPT as i32 => "[ACCEPT]".to_string(),
        c if c == VK_MODECHANGE as i32 => "[MODECHANGE]".to_string(),
        c if c == VK_SPACE as i32 => { is_char = true; " ".to_string() },
        c if c == VK_PRIOR as i32 => "[PAGE_UP]".to_string(),
        c if c == VK_NEXT as i32 => "[PAGE_DOWN]".to_string(),
        c if c == VK_END as i32 => "[END]".to_string(),
        c if c == VK_HOME as i32 => "[HOME]".to_string(),
        c if c == VK_LEFT as i32 => "[LEFT_ARROW]".to_string(),
        c if c == VK_UP as i32 => "[UP_ARROW]".to_string(),
        c if c == VK_RIGHT as i32 => "[RIGHT_ARROW]".to_string(),
        c if c == VK_DOWN as i32 => "[DOWN_ARROW]".to_string(),
        c if c == VK_SELECT as i32 => "[SELECT]".to_string(),
        c if c == VK_PRINT as i32 => "[PRINT]".to_string(),
        c if c == VK_EXECUTE as i32 => "[EXECUTE]".to_string(),
        c if c == VK_SNAPSHOT as i32 => "[PRINTSCREEN]".to_string(),
        c if c == VK_INSERT as i32 => "[INSERT]".to_string(),
        c if c == VK_DELETE as i32 => "[DELETE]".to_string(),
        c if c == VK_HELP as i32 => "[HELP]".to_string(),
        c if c == VK_LWIN as i32 => "[LWINKEY]".to_string(),
        c if c == VK_RWIN as i32 => "[RWINKEY]".to_string(),
        c if c == VK_APPS as i32 => "[APP_MENU]".to_string(),
        c if c == VK_SLEEP as i32 => "[SLEEP]".to_string(),
        c if c >= (VK_NUMPAD0 as i32) && c <= (VK_NUMPAD9 as i32) => format!("[NUMPAD_{}]", c - (VK_NUMPAD0 as i32)),
        c if c == VK_MULTIPLY as i32 => "[NUMPAD_*]".to_string(),
        c if c == VK_ADD as i32 => "[NUMPAD_+]".to_string(),
        c if c == VK_SEPARATOR as i32 => "[NUMPAD_SEPARATOR]".to_string(),
        c if c == VK_SUBTRACT as i32 => "[NUMPAD_-]".to_string(),
        c if c == VK_DECIMAL as i32 => "[NUMPAD_.]".to_string(),
        c if c == VK_DIVIDE as i32 => "[NUMPAD_/]".to_string(),
        c if c >= (VK_F1 as i32) && c <= (VK_F24 as i32) => format!("[F{}]", c - (VK_F1 as i32) + 1),
        c if c == VK_NUMLOCK as i32 => "[NUMLOCK]".to_string(),
        c if c == VK_SCROLL as i32 => "[SCROLLLOCK]".to_string(),
        c if c == VK_BROWSER_BACK as i32 => "[BROWSER_BACK]".to_string(),
        c if c == VK_BROWSER_FORWARD as i32 => "[BROWSER_FORWARD]".to_string(),
        c if c == VK_BROWSER_REFRESH as i32 => "[BROWSER_REFRESH]".to_string(),
        c if c == VK_BROWSER_STOP as i32 => "[BROWSER_STOP]".to_string(),
        c if c == VK_BROWSER_SEARCH as i32 => "[BROWSER_SEARCH]".to_string(),
        c if c == VK_BROWSER_FAVORITES as i32 => "[BROWSER_FAVORITES]".to_string(),
        c if c == VK_BROWSER_HOME as i32 => "[BROWSER_HOME]".to_string(),
        c if c == VK_VOLUME_MUTE as i32 => "[VOLUME_MUTE]".to_string(),
        c if c == VK_VOLUME_DOWN as i32 => "[VOLUME_DOWN]".to_string(),
        c if c == VK_VOLUME_UP as i32 => "[VOLUME_UP]".to_string(),
        c if c == VK_MEDIA_NEXT_TRACK as i32 => "[MEDIA_NEXT]".to_string(),
        c if c == VK_MEDIA_PREV_TRACK as i32 => "[MEDIA_PREV]".to_string(),
        c if c == VK_MEDIA_STOP as i32 => "[MEDIA_STOP]".to_string(),
        c if c == VK_MEDIA_PLAY_PAUSE as i32 => "[MEDIA_PLAY_PAUSE]".to_string(),
        c if c == VK_LAUNCH_MAIL as i32 => "[LAUNCH_MAIL]".to_string(),
        c if c == VK_LAUNCH_MEDIA_SELECT as i32 => "[LAUNCH_MEDIA_SELECT]".to_string(),
        c if c == VK_LAUNCH_APP1 as i32 => "[LAUNCH_APP1]".to_string(),
        c if c == VK_LAUNCH_APP2 as i32 => "[LAUNCH_APP2]".to_string(),
        _ => format!("[VK_0x{:X}]", vk_code),
    };
    (representation, is_char)
}
'''
'''--- activity_monitor_client_core/src/errors.rs ---
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("Configuration error: {0}")]
    Config(String),
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),
    #[error("Serialization error (JSON): {0}")]
    SerializationJson(#[from] serde_json::Error),
    #[error("Network error: {0}")]
    Network(#[from] reqwest::Error),
    #[error("Encryption error: {0}")]
    Encryption(String),
    #[error("Decryption error: {0}")]
    Decryption(String), // Though client mostly encrypts
    #[error("Windows API error: {context} (Code: {code})")]
    WinApi { context: String, code: u32 },
    #[error("Data storage error: {0}")]
    Storage(String),
    #[error("Hooking error: {0}")]
    Hook(String),
    #[error("Task join error: {0}")]
    JoinError(#[from] tokio::task::JoinError),
    #[error("Channel send error (std::mpsc): {0}")]
    StdMpscSend(String),
    #[error("Channel send error (tokio::mpsc): {0}")]
    TokioMpscSend(String),
    #[error("Channel receive error (tokio::oneshot): {0}")]
    TokioOneshotRecv(#[from] tokio::sync::oneshot::error::RecvError),
    #[error("Hex decoding error: {0}")]
    HexDecode(#[from] hex::FromHexError),
    #[error("Initialization failed: {0}")]
    Initialization(String),
    #[error("An unexpected error occurred: {0}")]
    Unknown(String),
}

pub fn win_api_error(context: &str) -> AppError {
    let code = unsafe { windows_sys::Win32::Foundation::GetLastError() };
    AppError::WinApi {
        context: context.to_string(),
        code,
    }
}
'''
'''--- activity_monitor_client_core/src/event_types.rs ---
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct LogEvent {
    pub id: Uuid,
    pub client_id: Uuid,
    pub timestamp: DateTime<Utc>, // Represents the start_time of the ApplicationActivity block
    pub application_name: String,
    pub initial_window_title: String,
    pub event_data: EventData,
    #[serde(default = "default_schema_version")]
    pub schema_version: u32,
}

fn default_schema_version() -> u32 { 2 } // Start with schema version 2 for this new format

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(tag = "type", content = "data")] // "type" will be "ApplicationActivity"
pub enum EventData {
    ApplicationActivity {
        start_time: DateTime<Utc>,
        end_time: DateTime<Utc>,
        typed_text: String,
        clipboard_actions: Vec<ClipboardActivity>,
        // final_window_title: String, // Optional: title at the end of the session
    },
    // Could add other distinct event types here if needed, e.g., SystemStatus, ClientStart, ClientStop
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ClipboardActivity {
    pub timestamp: DateTime<Utc>, // Specific timestamp of this clipboard action
    pub content_hash: String,
    pub content_preview: String,
    pub char_count: usize,
}

impl LogEvent {
    pub fn new_application_activity(
        client_id: Uuid,
        application_name: String,
        initial_window_title: String,
        start_time: DateTime<Utc>,
        end_time: DateTime<Utc>,
        typed_text: String,
        clipboard_actions: Vec<ClipboardActivity>,
    ) -> Self {
        LogEvent {
            id: Uuid::new_v4(),
            client_id,
            timestamp: start_time, // Main LogEvent timestamp is the session start
            application_name,
            initial_window_title,
            event_data: EventData::ApplicationActivity {
                start_time,
                end_time,
                typed_text,
                clipboard_actions,
            },
            schema_version: default_schema_version(),
        }
    }
}
'''
'''--- activity_monitor_client_core/src/internal_logger.rs ---
use crate::app_config::Settings;
use crate::errors::AppError;
use std::sync::Arc;
use std::str::FromStr;
use tracing_appender::rolling;
use tracing_subscriber::{fmt, EnvFilter, Layer, prelude::*};

pub fn init_logging(settings: &Arc<Settings>) -> Result<(), AppError> {
    // Create separate EnvFilter instances for each layer if they might differ or to avoid clone issues.
    let file_log_level_filter = EnvFilter::from_str(&settings.internal_log_level)
        .map_err(|e| AppError::Config(format!("Invalid internal_log_level for file: '{}': {}", settings.internal_log_level, e)))?;

    let log_dir = &settings.internal_log_file_dir;
    
    if !log_dir.exists() {
        std::fs::create_dir_all(log_dir)
            .map_err(|e| AppError::Initialization(format!("Failed to create log directory {:?}: {}", log_dir, e)))?;
    }
    
    let file_appender = rolling::daily(log_dir, &settings.internal_log_file_name);
    let (non_blocking_writer, guard) = tracing_appender::non_blocking(file_appender);
    
    let file_layer = fmt::layer()
        .with_writer(non_blocking_writer)
        .with_ansi(false)
        .with_thread_ids(true)
        .with_thread_names(true)
        .with_file(true)
        .with_line_number(true)
        .with_filter(file_log_level_filter); // Apply the filter for the file layer

    // Start with the registry and add the file layer.
    // The type of subscriber_builder will change as layers are added.
    let subscriber = tracing_subscriber::registry().with(file_layer);

    #[cfg(debug_assertions)]
    let subscriber = { // This shadows the previous `subscriber`, creating a new one with an added layer
        let console_log_level_filter = EnvFilter::from_str(&settings.internal_log_level)
            .map_err(|e| AppError::Config(format!("Invalid internal_log_level for console: '{}': {}", settings.internal_log_level, e)))?;

        let console_layer = fmt::layer()
            .with_writer(std::io::stderr)
            .with_thread_ids(true)
            .with_filter(console_log_level_filter);
        
        subscriber.with(console_layer) // Add the console layer to the existing subscriber
    };
    // #[cfg(not(debug_assertions))]
    // let subscriber = subscriber; // If not debug, `subscriber` remains the one with just the file layer.

    subscriber.try_init()
        .map_err(|e| AppError::Initialization(format!("Failed to set global tracing subscriber: {}", e)))?;

    std::mem::forget(guard);

    tracing::info!(
        "Internal diagnostics logger initialized. Level: {}, Output Directory: {:?}, File Name: {}",
        settings.internal_log_level,
        settings.internal_log_file_dir,
        settings.internal_log_file_name
    );

    Ok(())
}
'''
'''--- activity_monitor_client_core/src/main.rs ---
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use std::sync::Arc;
use tokio::signal;
use tokio::task::JoinHandle;
use tokio::time::Duration;
use futures::future::select_all;

mod app_config;
mod errors;
mod event_types;
mod internal_logger;
mod core_monitors;
mod processing;
mod storage;
mod network;
mod services;
mod system_utils;

use app_config::Settings;
use errors::AppError;

async fn bridge_std_to_tokio<T: Send + 'static>(
    std_rx: std::sync::mpsc::Receiver<T>,
    tokio_tx: tokio::sync::mpsc::Sender<T>,
    channel_name: &'static str,
) {
    tokio::task::spawn_blocking(move || {
        for data in std_rx {
            if tokio_tx.blocking_send(data).is_err() {
                tracing::error!("Bridge {}: Tokio channel closed while sending. Bridge task ending.", channel_name);
                break;
            }
        }
        tracing::info!("Bridge {}: Standard MPSC channel closed, bridge task for {} ending.", channel_name, channel_name);
    }).await.unwrap_or_else(|join_err| {
        tracing::error!("Bridge task for {} panicked: {}", channel_name, join_err);
    });
}

#[tokio::main]
async fn main() -> Result<(), AppError> {
    let settings = match Settings::new() {
        Ok(s) => s,
        Err(e) => {
            eprintln!("FATAL: Configuration error: {}. Ensure 'client_settings.toml' exists and is valid in expected locations.", e);
            #[cfg(debug_assertions)]
            std::thread::sleep(std::time::Duration::from_secs(5));
            return Err(e);
        }
    };

    if let Err(e) = internal_logger::init_logging(&settings) {
        eprintln!("FATAL: Internal logger initialization error: {}", e);
        #[cfg(debug_assertions)]
        std::thread::sleep(std::time::Duration::from_secs(5));
        return Err(e);
    };

    tracing::info!(
        "Application starting. Version: {}. Client ID: {}",
        env!("CARGO_PKG_VERSION"),
        settings.client_id
    );
    tracing::debug!("Loaded settings. Server URL: '{}'", settings.server_url);

    if let Err(e) = system_utils::startup::setup_autostart(&settings) {
        tracing::warn!("Failed to setup autostart: {}. Continuing execution...", e);
    }

    let (shutdown_tx, shutdown_rx_sync_manager) = tokio::sync::watch::channel(false);
    let shutdown_rx_event_processor = shutdown_tx.subscribe();
    let shutdown_rx_log_store = shutdown_tx.subscribe(); // Create and pass this

    let (raw_kb_std_tx, raw_kb_std_rx) = std::sync::mpsc::channel::<core_monitors::keyboard_capture::RawKeyboardData>();
    let (raw_clip_std_tx, raw_clip_std_rx) = std::sync::mpsc::channel::<core_monitors::clipboard_capture::RawClipboardData>();
    
    let (tokio_kb_tx, tokio_kb_rx) = tokio::sync::mpsc::channel(128);
    let (tokio_clip_tx, tokio_clip_rx) = tokio::sync::mpsc::channel(64);

    let _kbd_monitor_thread_handle = core_monitors::keyboard_capture::start_keyboard_monitoring(raw_kb_std_tx)?;
    tracing::info!("Keyboard monitor thread started.");
    
    let _clip_monitor_thread_handle = core_monitors::clipboard_capture::start_clipboard_monitoring(raw_clip_std_tx, Arc::clone(&settings))?;
    tracing::info!("Clipboard monitor thread started.");

    let kb_bridge_task = tokio::spawn(bridge_std_to_tokio(raw_kb_std_rx, tokio_kb_tx, "Keyboard"));
    let clip_bridge_task = tokio::spawn(bridge_std_to_tokio(raw_clip_std_rx, tokio_clip_tx, "Clipboard"));
    tracing::info!("Keyboard and Clipboard bridge tasks started.");

    // Pass shutdown_rx_log_store
    let (log_store_handle, log_store_task) = storage::log_store::create_log_store_handle_and_task(
        Arc::clone(&settings),
        128,
        shutdown_rx_log_store,
    );
    tracing::info!("LogStore actor task started.");

    let event_processor_task = tokio::spawn(processing::event_processor::run_event_processor(
        Arc::clone(&settings),
        tokio_kb_rx,
        tokio_clip_rx,
        log_store_handle.clone(),
        shutdown_rx_event_processor,
    ));
    tracing::info!("Event processor task started.");

    let data_sender = network::data_sender::DataSender::new(Arc::clone(&settings))?;
    tracing::info!("Network data sender initialized.");

    let sync_manager_task = tokio::spawn(services::sync_manager::run_sync_manager(
        Arc::clone(&settings),
        log_store_handle,
        data_sender,
        shutdown_rx_sync_manager,
    ));
    tracing::info!("Sync manager task started.");

    let mut app_logic_tasks: Vec<JoinHandle<Result<(), AppError>>> = vec![
        event_processor_task, 
        sync_manager_task,
        log_store_task,
    ];
    let bridge_join_handles = vec![kb_bridge_task, clip_bridge_task];

    #[cfg(windows)]
    let mut interrupt_signal_stream = signal::windows::ctrl_c().expect("Failed to listen for Ctrl-C");
    #[cfg(unix)]
    let mut interrupt_signal_stream = signal::unix::signal(signal::unix::SignalKind::interrupt()).expect("Failed to install SIGINT handler");

    tokio::select! {
        biased;

        _ = interrupt_signal_stream.recv() => {
            tracing::info!("Interrupt signal (Ctrl+C) received, initiating shutdown...");
        }
        
        res = async {
            if app_logic_tasks.is_empty() {
                std::future::pending().await
            } else {
                let (task_result, index, _) = select_all(app_logic_tasks.iter_mut()).await;
                (task_result, index)
            }
        } => {
            let (task_outcome, task_index) = res;
            tracing::error!(
                "Core application task at index {} exited prematurely. Outcome: {:?}",
                task_index, task_outcome
            );
        }
    }

    tracing::info!("Sending shutdown signal to all long-running tasks...");
    if shutdown_tx.send(true).is_err() {
        tracing::warn!("Failed to send shutdown signal (all receivers dropped). Tasks might have already terminated.");
    }

    tracing::info!("Waiting for application logic tasks to complete shutdown...");
    for (i, task_handle) in app_logic_tasks.into_iter().enumerate() {
        match tokio::time::timeout(Duration::from_secs(10), task_handle).await {
            Ok(Ok(Ok(_))) => tracing::debug!("Application task {} completed successfully during shutdown.", i),
            Ok(Ok(Err(e))) => tracing::error!("Application task {} completed with error during shutdown: {}", i, e),
            Ok(Err(e)) => tracing::error!("Application task {} panicked or was cancelled during shutdown: {}", i, e),
            Err(_) => tracing::warn!("Application task {} timed out during shutdown.", i),
        }
    }

    tracing::info!("Waiting for bridge tasks to complete...");
    for (i, task_handle) in bridge_join_handles.into_iter().enumerate() {
        match tokio::time::timeout(Duration::from_secs(5), task_handle).await {
            Ok(Ok(_)) => tracing::debug!("Bridge task {} completed.", i),
            Ok(Err(e)) => tracing::error!("Bridge task {} panicked: {}", i, e),
            Err(_) => tracing::warn!("Bridge task {} timed out.", i),
        }
    }
    
    tracing::info!("Application shutdown sequence complete.");
    Ok(())
}
'''
'''--- activity_monitor_client_core/src/network/data_sender.rs ---
// src/network/data_sender.rs

use crate::app_config::Settings;
use crate::errors::AppError;
use reqwest::{Client, Body};
use std::sync::Arc;
use std::time::Duration;

#[derive(Clone)] // Cloneable if DataSender needs to be shared (e.g. Arc<DataSender>)
pub struct DataSender {
    client: Client,
    settings: Arc<Settings>, // Store Arc<Settings> for access to server_url, client_id etc.
}

impl DataSender {
    pub fn new(settings: Arc<Settings>) -> Result<Self, AppError> {
        // Consider more robust timeout configurations
        let client = Client::builder()
            .timeout(Duration::from_secs(60)) // Overall request timeout
            .connect_timeout(Duration::from_secs(20)) // Connection phase timeout
            .user_agent(format!(
                "{}/{} (RustMonitorClient)", // Use a more descriptive user agent
                settings.app_name_for_autorun, // Assuming this is a good app identifier
                env!("CARGO_PKG_VERSION")
            ))
            .use_rustls_tls() // Prefer Rustls for TLS backend
            .build()?; // Converts reqwest::Error into AppError::Network via From trait
        Ok(Self { client, settings })
    }

    pub async fn send_log_batch(&self, encrypted_payload: Vec<u8>) -> Result<(), AppError> {
        tracing::info!(
            "DataSender: Sending log batch of {} bytes to {}",
            encrypted_payload.len(),
            self.settings.server_url // Access server_url from stored settings
        );
        
        let response_result = self.client
            .post(&self.settings.server_url)
            .header("Content-Type", "application/octet-stream")
            .header("X-Client-ID", self.settings.client_id.to_string()) // Send client_id
            .body(Body::from(encrypted_payload)) // reqwest::Body can take Vec<u8>
            .send()
            .await;

        match response_result {
            Ok(response) => {
                // error_for_status will turn 4xx and 5xx responses into an Err
                match response.error_for_status() {
                    Ok(successful_response) => {
                        tracing::info!(
                            "DataSender: Log batch sent successfully. Server status: {}",
                            successful_response.status()
                        );
                        // Optionally log response body if needed for debugging (usually small for success)
                        // let response_text = successful_response.text().await.unwrap_or_default();
                        // tracing::debug!("DataSender: Server success response body: {}", response_text);
                        Ok(())
                    }
                    Err(reqwest_error_with_status) => {
                        // This error already contains status and potentially the response body if read
                        tracing::error!("DataSender: Server responded with HTTP error: {}", reqwest_error_with_status);
                        Err(AppError::Network(reqwest_error_with_status))
                    }
                }
            }
            Err(e) => { // Network-level error (DNS, connection refused, etc.)
                tracing::error!("DataSender: HTTP request to send logs failed: {}", e);
                Err(AppError::Network(e))
            }
        }
    }
}
'''
'''--- activity_monitor_client_core/src/network/encryption.rs ---
// src/network/encryption.rs

use crate::errors::AppError;
use aes_gcm::aead::{Aead, KeyInit, OsRng, AeadCore}; // AeadCore for generate_nonce
use aes_gcm::{Aes256Gcm, Nonce}; // Or your specific AES variant

const NONCE_SIZE: usize = 12; // Standard for AES-GCM

pub fn encrypt_payload(data: &[u8], key: &[u8; 32]) -> Result<Vec<u8>, AppError> {
    let cipher = Aes256Gcm::new_from_slice(key)
        .map_err(|e| AppError::Encryption(format!("Failed to create AES cipher: {}", e)))?;
    
    let nonce_val = Aes256Gcm::generate_nonce(&mut OsRng); // Returns GenericArray
    // The Nonce type from aes-gcm is usually a wrapper around GenericArray of the correct size.
    // If encrypt takes &GenericArray directly, this conversion might not be needed.
    // Let's assume encrypt takes a Nonce type or compatible slice.
    let nonce_for_encryption = Nonce::from_slice(nonce_val.as_slice());

    // encrypt() typically appends the authentication tag to the ciphertext
    let ciphertext_with_tag = cipher.encrypt(nonce_for_encryption, data)
        .map_err(|e| AppError::Encryption(format!("AES encryption failed: {}", e)))?;

    // Prepend nonce to (ciphertext + tag)
    let mut result = Vec::with_capacity(NONCE_SIZE + ciphertext_with_tag.len());
    result.extend_from_slice(nonce_val.as_slice()); // Prepend the raw nonce bytes
    result.extend_from_slice(&ciphertext_with_tag);

    Ok(result)
}

// Decryption is primarily for the server, but useful for testing or if client ever receives encrypted data.
#[allow(dead_code)]
pub fn decrypt_payload(encrypted_data_with_nonce: &[u8], key: &[u8; 32]) -> Result<Vec<u8>, AppError> {
    if encrypted_data_with_nonce.len() < NONCE_SIZE {
        return Err(AppError::Decryption("Encrypted data too short to contain nonce.".to_string()));
    }

    let cipher = Aes256Gcm::new_from_slice(key)
        .map_err(|e| AppError::Decryption(format!("Failed to create AES cipher for decryption: {}", e)))?;

    let (nonce_bytes, ciphertext_with_tag) = encrypted_data_with_nonce.split_at(NONCE_SIZE);
    let nonce = Nonce::from_slice(nonce_bytes);

    // decrypt() expects the ciphertext to contain the authentication tag at its end
    cipher.decrypt(nonce, ciphertext_with_tag)
        .map_err(|e| AppError::Decryption(format!("AES decryption failed (MAC check likely failed): {}", e)))
}
'''
'''--- activity_monitor_client_core/src/network/mod.rs ---
// src/network/mod.rs

pub mod encryption;
pub mod data_sender;
'''
'''--- activity_monitor_client_core/src/processing/event_processor.rs ---
// src/processing/event_processor.rs

use crate::app_config::Settings;
use crate::event_types::{LogEvent, EventData, ClipboardActivity}; // Assuming these are in crate::event_types
use crate::storage::log_store::LogStoreHandle; // Assuming this is in crate::storage::log_store
use crate::core_monitors::keyboard_capture::RawKeyboardData;
use crate::core_monitors::clipboard_capture::RawClipboardData;
use crate::errors::AppError; // Assuming this is in crate::errors
use tokio::sync::mpsc;
use tokio::time::{interval, Interval, Duration, MissedTickBehavior};
use std::sync::Arc;
use chrono::{DateTime, Utc};
use sha2::{Sha256, Digest}; // For hashing clipboard content

struct CurrentSession {
    application_name: String,
    initial_window_title: String,
    latest_window_title: String, // Track the most recent title within the session
    start_time: DateTime<Utc>,
    typed_text: String,
    clipboard_actions: Vec<ClipboardActivity>,
}

impl CurrentSession {
    fn new(app_name: String, window_title: String, start_time: DateTime<Utc>) -> Self {
        CurrentSession {
            application_name: app_name,
            initial_window_title: window_title.clone(),
            latest_window_title: window_title,
            start_time,
            typed_text: String::new(),
            clipboard_actions: Vec::new(),
        }
    }

    fn is_empty(&self) -> bool {
        self.typed_text.is_empty() && self.clipboard_actions.is_empty()
    }
}

pub async fn run_event_processor(
    settings: Arc<Settings>,
    mut raw_keyboard_rx: mpsc::Receiver<RawKeyboardData>,
    mut raw_clipboard_rx: mpsc::Receiver<RawClipboardData>,
    log_store: LogStoreHandle,
    mut shutdown_rx: tokio::sync::watch::Receiver<bool>,
) -> Result<(), AppError> {
    tracing::info!(
        "Event processor started. Grouping by application. Periodic flush: {}s",
        settings.processor_periodic_flush_interval_secs
    );

    let mut current_session: Option<CurrentSession> = None;

    let mut periodic_flush_interval_opt: Option<Interval> = if settings.processor_periodic_flush_interval_secs > 0 {
        let mut intv = interval(Duration::from_secs(settings.processor_periodic_flush_interval_secs));
        intv.set_missed_tick_behavior(MissedTickBehavior::Delay);
        Some(intv)
    } else {
        None
    };

    loop {
        let tick_future = async {
            if let Some(ref mut interval) = periodic_flush_interval_opt.as_mut() {
                if current_session.is_some() {
                    interval.tick().await;
                    return Some(()); 
                }
            }
            std::future::pending().await // Pend if no interval or no session
        };

        tokio::select! {
            biased;

            _ = shutdown_rx.changed() => {
                if *shutdown_rx.borrow_and_update() {
                    tracing::info!("Event processor: Shutdown signal received.");
                    if let Some(session) = current_session.take() {
                        if !session.is_empty() {
                            finalize_and_store_session(session, Utc::now(), &settings, &log_store).await;
                        }
                    }
                    break; 
                }
            }

            maybe_tick_completed = tick_future => {
                if maybe_tick_completed.is_some() {
                    if let Some(session) = current_session.take() {
                         tracing::debug!("Event processor: Periodic flush for app: {}", session.application_name);
                         finalize_and_store_session(session, Utc::now(), &settings, &log_store).await;
                    }
                }
            }

            Some(kbd_data) = raw_keyboard_rx.recv() => {
                tracing::trace!("Event processor: RawKbd: '{}' in App:'{}'", kbd_data.key_value, kbd_data.foreground_app_name);
                match current_session.as_mut() {
                    Some(session) if session.application_name == kbd_data.foreground_app_name => {
                        if kbd_data.is_char && !kbd_data.key_value.starts_with('[') {
                            session.typed_text.push_str(&kbd_data.key_value);
                        } else if !kbd_data.is_char {
                            session.typed_text.push_str(&format!("{} ", kbd_data.key_value.trim()));
                        }
                        session.latest_window_title = kbd_data.foreground_window_title;
                    }
                    _ => {
                        if let Some(old_session) = current_session.take() {
                            if !old_session.is_empty() {
                                finalize_and_store_session(old_session, kbd_data.timestamp, &settings, &log_store).await;
                            }
                        }
                        let mut new_session = CurrentSession::new(
                            kbd_data.foreground_app_name.clone(),
                            kbd_data.foreground_window_title.clone(),
                            kbd_data.timestamp
                        );
                        if kbd_data.is_char && !kbd_data.key_value.starts_with('[') {
                            new_session.typed_text.push_str(&kbd_data.key_value);
                        } else if !kbd_data.is_char {
                            new_session.typed_text.push_str(&format!("{} ", kbd_data.key_value.trim()));
                        }
                        current_session = Some(new_session);
                    }
                }
            }

            Some(clip_data) = raw_clipboard_rx.recv() => {
                tracing::trace!("Event processor: RawClip in App:'{}'", clip_data.foreground_app_name);
                let clipboard_activity = ClipboardActivity {
                    timestamp: clip_data.timestamp,
                    content_hash: {
                        let mut hasher = Sha256::new();
                        hasher.update(clip_data.text_content.as_bytes());
                        format!("{:x}", hasher.finalize())
                    },
                    content_preview: clip_data.text_content.chars().take(100).collect(),
                    char_count: clip_data.text_content.chars().count(),
                };

                match current_session.as_mut() {
                    Some(session) if session.application_name == clip_data.foreground_app_name => {
                        session.clipboard_actions.push(clipboard_activity);
                        session.latest_window_title = clip_data.foreground_window_title;
                    }
                    _ => {
                        if let Some(old_session) = current_session.take() {
                             if !old_session.is_empty() {
                                finalize_and_store_session(old_session, clip_data.timestamp, &settings, &log_store).await;
                            }
                        }
                        let mut new_session = CurrentSession::new(
                            clip_data.foreground_app_name.clone(),
                            clip_data.foreground_window_title.clone(),
                            clip_data.timestamp
                        );
                        new_session.clipboard_actions.push(clipboard_activity);
                        current_session = Some(new_session);
                    }
                }
            }

            else => {
                tracing::info!("Event processor: Input channels closed. Finalizing any pending session.");
                if let Some(session) = current_session.take() {
                     if !session.is_empty() {
                        finalize_and_store_session(session, Utc::now(), &settings, &log_store).await;
                    }
                }
                break;
            }
        }
    }
    tracing::info!("Event processor shut down.");
    Ok(())
}

async fn finalize_and_store_session(
    session: CurrentSession,
    end_time: DateTime<Utc>,
    settings: &Arc<Settings>,
    log_store: &LogStoreHandle,
) {
    if session.is_empty() {
        tracing::trace!("Event processor: Skipping storage of empty session for app: {}", session.application_name);
        return;
    }

    tracing::debug!(
        "Event processor: Finalizing session for app: '{}', initial_title: '{}', typed_len: {}, clips: {}, start: {}, end: {}",
        session.application_name,
        session.initial_window_title,
        session.typed_text.len(), // Using len() for byte length, chars().count() for char count
        session.clipboard_actions.len(),
        session.start_time,
        end_time
    );

    let log_event = LogEvent::new_application_activity(
        settings.client_id,
        session.application_name,
        session.initial_window_title, // Could use session.latest_window_title if preferred
        session.start_time,
        end_time,
        session.typed_text.trim_end().to_string(),
        session.clipboard_actions,
    );

    if let Err(e) = log_store.add_event(log_event).await {
        tracing::error!("Event processor: Failed to store finalized session event: {}", e);
    }
}
'''
'''--- activity_monitor_client_core/src/processing/mod.rs ---
// src/processing/mod.rs

pub mod event_processor;
'''
'''--- activity_monitor_client_core/src/services/mod.rs ---
// src/services/mod.rs

pub mod sync_manager;
'''
'''--- activity_monitor_client_core/src/services/sync_manager.rs ---
// src/services/sync_manager.rs

use crate::app_config::Settings;
use crate::errors::AppError;
use crate::storage::log_store::LogStoreHandle;
use crate::network::data_sender::DataSender;
use crate::network::encryption::encrypt_payload; // Assuming this is in crate::network::encryption
use std::sync::Arc;
use std::time::Duration;
use tokio::time::{sleep, MissedTickBehavior}; // Added MissedTickBehavior
use uuid::Uuid; // For LogEvent IDs

pub async fn run_sync_manager(
    settings: Arc<Settings>,
    log_store: LogStoreHandle,
    data_sender: DataSender,
    mut shutdown_rx: tokio::sync::watch::Receiver<bool>, // For graceful shutdown
) -> Result<(), AppError> {
    tracing::info!(
        "SyncManager: Started. Sync interval: {}s, Retry interval: {}s",
        settings.sync_interval,
        settings.retry_interval_on_fail
    );

    let mut interval_timer = tokio::time::interval(Duration::from_secs(settings.sync_interval));
    interval_timer.set_missed_tick_behavior(MissedTickBehavior::Delay); // Or Skip
    // interval_timer.tick().await; // Consume initial immediate tick if not desired on startup

    loop {
        let mut perform_sync_now = false;
        let mut shutdown_requested = *shutdown_rx.borrow();

        if shutdown_requested {
            tracing::info!("SyncManager: Shutdown signal received, attempting one final sync.");
            perform_sync_now = true;
        } else {
            tokio::select! {
                biased; // Prioritize shutdown signal

                _ = shutdown_rx.changed() => {
                    if *shutdown_rx.borrow_and_update() { // Consume the change
                        tracing::info!("SyncManager: Shutdown signal updated, attempting final sync.");
                        shutdown_requested = true;
                        perform_sync_now = true;
                    } else {
                        // Spurious wakeup or signal toggled back, continue normal interval.
                        continue; // Re-evaluate select
                    }
                }
                _ = interval_timer.tick() => {
                    tracing::debug!("SyncManager: Interval tick for sync.");
                    perform_sync_now = true;
                }
            };
        }
        
        if perform_sync_now {
            tracing::info!("SyncManager: Checking for logs to sync...");
            match log_store.get_batch_for_sync(settings.max_events_per_sync_batch).await {
                Ok(events_batch) if !events_batch.is_empty() => {
                    let batch_size = events_batch.len();
                    let batch_event_ids: Vec<Uuid> = events_batch.iter().map(|e| e.id).collect();
                    tracing::info!("SyncManager: Found {} events in batch for sync. First ID: {:?}", batch_size, batch_event_ids.first());

                    match serde_json::to_vec(&events_batch) {
                        Ok(serialized_data) => {
                            match encrypt_payload(&serialized_data, &settings.encryption_key) {
                                Ok(encrypted_payload) => {
                                    let mut attempts = 0;
                                    loop { // Retry loop for sending this specific batch
                                        attempts += 1;
                                        match data_sender.send_log_batch(encrypted_payload.clone()).await {
                                            Ok(_) => {
                                                tracing::info!("SyncManager: Batch of {} events synced successfully (attempt {}).", batch_size, attempts);
                                                if let Err(e) = log_store.confirm_events_synced(batch_event_ids.clone()).await {
                                                    tracing::error!(
                                                        "SyncManager: CRITICAL - Failed to confirm sync for batch {:?}: {}. Data may be resent.",
                                                        batch_event_ids.first(), e
                                                    );
                                                }
                                                break; // Break from retry loop
                                            }
                                            Err(e) => {
                                                tracing::warn!(
                                                    "SyncManager: Failed to send batch (attempt {}/{}): {}",
                                                    attempts, settings.max_retries_per_batch, e
                                                );
                                                if attempts >= settings.max_retries_per_batch || shutdown_requested {
                                                    tracing::error!(
                                                        "SyncManager: Max retries ({}) reached or shutdown requested for batch {:?}. Batch remains in store.",
                                                        settings.max_retries_per_batch, batch_event_ids.first()
                                                    );
                                                    break; // Break from retry loop, batch remains in store
                                                }
                                                // Simple fixed retry interval, could be exponential backoff
                                                sleep(Duration::from_secs(settings.retry_interval_on_fail)).await;
                                            }
                                        }
                                    }
                                }
                                Err(e) => {
                                    tracing::error!("SyncManager: Failed to encrypt batch: {}. Batch will be retried later.", e);
                                }
                            }
                        }
                        Err(e) => {
                            tracing::error!("SyncManager: Failed to serialize batch for encryption: {}. Batch will be retried later.", e);
                        }
                    }
                }
                Ok(_) => { // Batch was empty
                    tracing::info!("SyncManager: No new events to sync.");
                }
                Err(e) => {
                    tracing::error!("SyncManager: Failed to get batch from log store: {}. Retrying after interval.", e);
                }
            }
        } // end if perform_sync_now

        if shutdown_requested {
            tracing::info!("SyncManager: Finished final sync attempt due to shutdown signal.");
            break; // Exit the main sync loop
        }
    }
    tracing::info!("SyncManager shut down.");
    Ok(())
}
'''
'''--- activity_monitor_client_core/src/storage/log_store.rs ---
use crate::app_config::Settings;
use crate::event_types::LogEvent;
use crate::errors::AppError;
use std::fs::{self, File, OpenOptions};
use std::io::{BufRead, BufReader, BufWriter, Write, ErrorKind};
use std::path::PathBuf;
use std::sync::Arc;
use tempfile::NamedTempFile;
use tokio::sync::{mpsc, oneshot};
use tokio::time::{interval, Duration, MissedTickBehavior};
use uuid::Uuid;
use chrono::Utc;

#[derive(Clone)]
pub struct LogStoreHandle {
    tx: mpsc::Sender<LogStoreCommand>,
}

enum LogStoreCommand {
    AddEvent(LogEvent, oneshot::Sender<Result<(), AppError>>),
    GetBatch(usize, oneshot::Sender<Result<Vec<LogEvent>, AppError>>),
    ConfirmSync(Vec<Uuid>, oneshot::Sender<Result<(), AppError>>),
}

impl LogStoreHandle {
    pub async fn add_event(&self, event: LogEvent) -> Result<(), AppError> {
        let (resp_tx, resp_rx) = oneshot::channel();
        self.tx.send(LogStoreCommand::AddEvent(event, resp_tx)).await
            .map_err(|e| AppError::TokioMpscSend(format!("LogStore add_event send failed: {}", e)))?;
        resp_rx.await.map_err(AppError::TokioOneshotRecv)?
    }

    pub async fn get_batch_for_sync(&self, limit: usize) -> Result<Vec<LogEvent>, AppError> {
        let (resp_tx, resp_rx) = oneshot::channel();
        self.tx.send(LogStoreCommand::GetBatch(limit, resp_tx)).await
            .map_err(|e| AppError::TokioMpscSend(format!("LogStore get_batch send failed: {}", e)))?;
        resp_rx.await.map_err(AppError::TokioOneshotRecv)?
    }

    pub async fn confirm_events_synced(&self, ids: Vec<Uuid>) -> Result<(), AppError> {
        let (resp_tx, resp_rx) = oneshot::channel();
        self.tx.send(LogStoreCommand::ConfirmSync(ids, resp_tx)).await
            .map_err(|e| AppError::TokioMpscSend(format!("LogStore confirm_sync send failed: {}", e)))?;
        resp_rx.await.map_err(AppError::TokioOneshotRecv)?
    }
}

struct LogStoreActor {
    settings: Arc<Settings>,
    file_path: PathBuf,
}

impl LogStoreActor {
    fn new(settings: Arc<Settings>) -> Result<Self, AppError> {
        let file_path = settings.log_file_path.clone();
        if let Some(parent) = file_path.parent() {
            if !parent.exists() {
                fs::create_dir_all(parent)
                    .map_err(|e| AppError::Initialization(format!("Failed to create log directory {:?}: {}", parent, e)))?;
            }
        }
        OpenOptions::new().create(true).append(true).open(&file_path)?;
        tracing::info!("LogStoreActor initialized. Storage file: {:?}", file_path);
        Ok(Self { settings, file_path })
    }

    async fn handle_command(&mut self, command: LogStoreCommand) {
        match command {
            LogStoreCommand::AddEvent(event, responder) => {
                let res = self.write_event_to_file(&event);
                let _ = responder.send(res);
            }
            LogStoreCommand::GetBatch(limit, responder) => {
                let res = self.read_batch_from_file(limit);
                let _ = responder.send(res);
            }
            LogStoreCommand::ConfirmSync(ids, responder) => {
                let res = self.remove_events_from_file(&ids);
                let _ = responder.send(res);
            }
        }
    }

    fn deserialize_line(line: &str, line_num: usize) -> Option<LogEvent> {
        if line.trim().is_empty() { return None; }
        match serde_json::from_str::<LogEvent>(line) {
            Ok(event) => Some(event),
            Err(e) => {
                tracing::warn!(
                    "LogStore: Failed to deserialize event from log store file at line {}: {}. Line snippet: '{}'",
                    line_num, e, line.chars().take(100).collect::<String>()
                );
                None
            }
        }
    }

    fn write_event_to_file(&mut self, event: &LogEvent) -> Result<(), AppError> {
        if let Some(max_size_mb) = self.settings.max_log_file_size_mb {
            match std::fs::metadata(&self.file_path) {
                Ok(metadata) => {
                    let max_size_bytes = max_size_mb * 1024 * 1024;
                    if metadata.len() > max_size_bytes {
                        let is_stuck = match self.read_batch_from_file(1) {
                            Ok(batch) => batch.is_empty(),
                            Err(_) => true,
                        };

                        if is_stuck && metadata.len() > (max_size_bytes as f64 * 1.1) as u64 {
                             tracing::error!(
                                "LogStore: Log file {:?} (size {}B) exceeds max size ({}MB) and appears stuck. \
                                Halting writes to prevent disk exhaustion. Event ID {:?} will NOT be written.",
                                self.file_path, metadata.len(), max_size_mb, event.id
                            );
                            return Err(AppError::Storage(format!(
                                "Log file full ({}MB limit) and not shrinking. Halting writes.", max_size_mb
                            )));
                        } else if metadata.len() > max_size_bytes {
                            tracing::warn!(
                               "LogStore: Log file {:?} (size {}B) exceeds max size ({}MB). Will attempt to write event ID {:?}. \
                               Sync process should clear space soon.",
                               self.file_path, metadata.len(), max_size_mb, event.id
                           );
                        }
                    }
                }
                Err(e) if e.kind() == ErrorKind::NotFound => { /* File doesn't exist yet, will be created */ }
                Err(e) => {
                    tracing::warn!("LogStore: Could not get metadata for log file {:?}: {}. Proceeding with write.", self.file_path, e);
                }
            }
        }

        if let Some(parent_dir) = self.file_path.parent() {
            if !parent_dir.exists() {
                fs::create_dir_all(parent_dir)
                    .map_err(|e| AppError::Storage(format!("Failed to create log directory {:?}: {}", parent_dir, e)))?;
            }
        }

        let mut file = OpenOptions::new().create(true).append(true).open(&self.file_path)?;
        let json_event = serde_json::to_string(event)?;
        writeln!(file, "{}", json_event)?;
        tracing::trace!("LogStore: Event {:?} written to log store file {:?}", event.id, self.file_path);
        Ok(())
    }

    fn read_batch_from_file(&self, limit: usize) -> Result<Vec<LogEvent>, AppError> {
        if limit == 0 {
            return Ok(Vec::new());
        }

        let file = match File::open(&self.file_path) {
            Ok(f) => f,
            Err(e) if e.kind() == ErrorKind::NotFound => return Ok(Vec::new()),
            Err(e) => return Err(AppError::Io(e)),
        };
        let reader = BufReader::new(file);
        let mut batch = Vec::with_capacity(std::cmp::min(limit, 1000));

        for (idx, line_res) in reader.lines().enumerate() {
            if batch.len() >= limit {
                break;
            }
            let line = line_res?;
            if let Some(event) = Self::deserialize_line(&line, idx + 1) {
                batch.push(event);
            }
        }
        tracing::debug!("LogStore: Read {} events for batch (limit {}) from log store file {:?}.", batch.len(), limit, self.file_path);
        Ok(batch)
    }

    fn remove_events_from_file(&mut self, ids_to_remove: &[Uuid]) -> Result<(), AppError> {
        if ids_to_remove.is_empty() {
            tracing::debug!("LogStore: remove_events_from_file called with no IDs to remove.");
            return Ok(());
        }

        let parent_dir = self.file_path.parent().ok_or_else(|| AppError::Storage("Log file path has no parent.".to_string()))?;
        let temp_file = NamedTempFile::new_in(parent_dir)?;

        let mut removed_count = 0;
        let mut lines_kept = 0;

        let original_file = match File::open(&self.file_path) {
            Ok(f) => f,
            Err(e) if e.kind() == ErrorKind::NotFound => {
                tracing::warn!("LogStore: Original log file {:?} not found during remove_events_from_file. Nothing to remove.", self.file_path);
                return Ok(());
            }
            Err(e) => return Err(AppError::Io(e)),
        };
        let reader = BufReader::new(original_file);
        let mut writer = BufWriter::new(File::create(temp_file.path())?);

        for (idx, line_res) in reader.lines().enumerate() {
            let line_num = idx + 1;
            let line = line_res?;

            if let Some(event) = Self::deserialize_line(&line, line_num) {
                if ids_to_remove.contains(&event.id) {
                    removed_count += 1;
                } else {
                    writeln!(writer, "{}", line)?;
                    lines_kept += 1;
                }
            } else {
                if !line.trim().is_empty() {
                     writeln!(writer, "{}", line)?;
                     lines_kept +=1;
                     tracing::warn!("LogStore: Kept an unparseable line (line {}) during rewrite as its ID could not be checked.", line_num);
                }
            }
        }
        writer.flush()?;
        drop(writer);

        temp_file.persist(&self.file_path).map_err(|e| {
            AppError::Storage(format!("Failed to persist temp log file over original: {}. Original path: {:?}, Temp path: {:?}", e.error, self.file_path, e.file.path()))
        })?;

        tracing::info!(
            "LogStore: Events removal complete. IDs to remove: {}. Actual removed: {}. Lines kept: {}. File: {:?}",
            ids_to_remove.len(), removed_count, lines_kept, self.file_path
        );
        Ok(())
    }

    async fn periodic_cleanup(&mut self) {
        if self.settings.local_log_cache_retention_days == 0 {
            tracing::debug!("LogStore: Periodic cleanup disabled (retention_days = 0).");
            return;
        }
        let retention_duration = chrono::Duration::days(self.settings.local_log_cache_retention_days as i64);
        let cutoff_time = Utc::now() - retention_duration;
        tracing::info!(
            "LogStore: Running periodic cleanup for logs older than {} days (cutoff: {}). File: {:?}",
            self.settings.local_log_cache_retention_days, cutoff_time, self.file_path
        );

        let parent_dir = match self.file_path.parent() {
            Some(p) => p,
            None => {
                tracing::error!("LogStore: Cleanup failed - Log file path has no parent: {:?}", self.file_path);
                return;
            }
        };
        let temp_file = match NamedTempFile::new_in(parent_dir) {
            Ok(tf) => tf,
            Err(e) => {
                tracing::error!("LogStore: Cleanup failed - Could not create temp file: {}", e);
                return;
            }
        };
        let temp_file_path_for_log = temp_file.path().to_path_buf();

        let mut removed_count = 0;
        let mut lines_kept = 0;

        let original_file = match File::open(&self.file_path) {
            Ok(f) => f,
            Err(e) if e.kind() == ErrorKind::NotFound => {
                tracing::debug!("LogStore: Cleanup - Original log file {:?} not found. Nothing to clean.", self.file_path);
                return;
            }
            Err(e) => {
                tracing::error!("LogStore: Cleanup failed - Could not open original log file {:?}: {}", self.file_path, e);
                return;
            }
        };
        let reader = BufReader::new(original_file);
        
        // CORRECTED PART: Handle Result from File::create
        let mut writer = match File::create(temp_file.path()) {
            Ok(f) => BufWriter::new(f),
            Err(e) => {
                tracing::error!("LogStore: Cleanup failed - Could not create writer for temp file {:?}: {}", temp_file.path(), e);
                return;
            }
        };

        for (idx, line_res) in reader.lines().enumerate() {
            let line_num = idx + 1;
            match line_res {
                Ok(line) => {
                    if let Some(event) = Self::deserialize_line(&line, line_num) {
                        if event.timestamp >= cutoff_time {
                            if let Err(e) = writeln!(writer, "{}", line) {
                                tracing::error!("LogStore: Cleanup failed - Error writing kept event to temp file: {}", e);
                                return;
                            }
                            lines_kept += 1;
                        } else {
                            tracing::trace!("LogStore: Cleaning up old event ID {:?}, timestamp {}", event.id, event.timestamp);
                            removed_count += 1;
                        }
                    } else {
                        if !line.trim().is_empty() {
                            if let Err(e) = writeln!(writer, "{}", line) {
                                tracing::error!("LogStore: Cleanup failed - Error writing unparseable (but kept) line to temp file: {}", e);
                                return;
                            }
                            lines_kept +=1;
                            tracing::warn!("LogStore: Cleanup - Kept an unparseable line (line {}) during rewrite.", line_num);
                        }
                    }
                }
                Err(e) => {
                    tracing::error!("LogStore: Cleanup failed - Error reading line {} from original log file: {}", line_num, e);
                    return;
                }
            }
        }

        if let Err(e) = writer.flush() {
             tracing::error!("LogStore: Cleanup failed - Error flushing temp file: {}", e);
             return;
        }
        drop(writer);

        if removed_count > 0 || (lines_kept > 0 && removed_count == 0) || (lines_kept == 0 && removed_count == 0 && fs::metadata(&self.file_path).map(|m| m.len() > 0).unwrap_or(false)) {
            match temp_file.persist(&self.file_path) {
                Ok(_) => {
                     tracing::info!(
                        "LogStore: Periodic cleanup successful. Removed: {}. Kept: {}. File: {:?}",
                        removed_count, lines_kept, self.file_path
                    );
                }
                Err(e) => {
                    tracing::error!(
                        "LogStore: Cleanup failed - Could not persist temp file over original: {}. Original path: {:?}, Temp path: {:?}. Data may be in temp file.",
                        e.error, self.file_path, temp_file_path_for_log);
                }
            }
        } else {
            tracing::debug!(
                "LogStore: Periodic cleanup resulted in no changes to file content (original was empty or no events expired/were removed). Temp file {:?} will be removed.",
                temp_file_path_for_log
            );
        }
    }
}

pub async fn run_log_store_actor(
    settings: Arc<Settings>,
    mut rx: mpsc::Receiver<LogStoreCommand>,
    mut shutdown_rx: tokio::sync::watch::Receiver<bool>,
) -> Result<(), AppError> {
    let mut actor = LogStoreActor::new(settings.clone())?;
    tracing::info!("LogStore actor task started.");

    let mut cleanup_interval_opt = if actor.settings.local_log_cache_retention_days > 0 {
        let initial_delay = Duration::from_secs(60);
        let periodic_interval_duration = Duration::from_secs(60 * 60 * 6); // Every 6 hours

        let stream = async_stream::stream! {
            tokio::time::sleep(initial_delay).await;
            yield (); 

            let mut periodic_timer = interval(periodic_interval_duration);
            periodic_timer.set_missed_tick_behavior(MissedTickBehavior::Delay);
            loop {
                periodic_timer.tick().await;
                yield ();
            }
        };
        Some(Box::pin(stream))
    } else {
        None
    };

    loop {
        let cleanup_fut = async {
            if let Some(ref mut interval_pinned_stream) = cleanup_interval_opt {
                use futures::StreamExt; 
                interval_pinned_stream.next().await;
                return Some(());
            }
            std::future::pending::<Option<()>>().await
        };

        tokio::select! {
            biased;

            _ = shutdown_rx.changed() => {
                if *shutdown_rx.borrow_and_update() {
                    tracing::info!("LogStore: Shutdown signal received.");
                    break;
                }
            }

            tick_result = cleanup_fut => {
                if tick_result.is_some() {
                    actor.periodic_cleanup().await;
                }
            }

            Some(command) = rx.recv() => {
                actor.handle_command(command).await;
            }
            else => {
                tracing::info!("LogStore: Command channel closed. Actor shutting down.");
                break;
            }
        }
    }
    tracing::info!("LogStore actor task shut down.");
    Ok(())
}

pub fn create_log_store_handle_and_task(
    settings: Arc<Settings>,
    buffer_size: usize,
    shutdown_rx: tokio::sync::watch::Receiver<bool>,
) -> (LogStoreHandle, tokio::task::JoinHandle<Result<(), AppError>>) {
    let (tx, rx_for_actor) = mpsc::channel(buffer_size);
    let handle = LogStoreHandle { tx };
    let task_settings = Arc::clone(&settings);
    let task = tokio::spawn(run_log_store_actor(task_settings, rx_for_actor, shutdown_rx));
    (handle, task)
}
'''
'''--- activity_monitor_client_core/src/storage/mod.rs ---
// src/storage/mod.rs

pub mod log_store;
'''
'''--- activity_monitor_client_core/src/system_utils/mod.rs ---
// src/system_utils/mod.rs

pub mod startup;
'''
'''--- activity_monitor_client_core/src/system_utils/startup.rs ---
// src/system_utils/startup.rs

use crate::app_config::Settings; // Assumes Settings is in crate::app_config
use crate::errors::AppError;    // Assumes AppError is in crate::errors
use std::env;
use std::sync::Arc;
use winreg::enums::*; // For KEY_WRITE, REG_CREATED_NEW_KEY, etc.
use winreg::RegKey;

pub fn setup_autostart(settings: &Arc<Settings>) -> Result<(), AppError> {
    // HKEY_CURRENT_USER for current user login
    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
    let path = r"Software\Microsoft\Windows\CurrentVersion\Run"; // Standard Run key
    
    // create_subkey opens if exists, creates if not.
    let (key, disposition) = hkcu.create_subkey(&path)
        .map_err(|e| AppError::Io(e))?; // Convert winreg::Error to AppError::Io

    match disposition {
        REG_CREATED_NEW_KEY => tracing::info!("Startup: Registry Run key created at HKEY_CURRENT_USER\\{}", path),
        REG_OPENED_EXISTING_KEY => tracing::debug!("Startup: Registry Run key opened at HKEY_CURRENT_USER\\{}", path),
    }

    let current_exe_path = env::current_exe()
        .map_err(|e| AppError::Io(e))?;
    let exe_path_str = current_exe_path.to_string_lossy(); // Handles potential non-UTF8 paths gracefully for display

    // Check if our app's autorun entry already exists and is correct
    match key.get_value::<String, _>(&settings.app_name_for_autorun) {
        Ok(existing_path_val) if existing_path_val == exe_path_str.as_ref() => {
            tracing::info!(
                "Startup: Autostart entry for '{}' is already correctly configured to '{}'.",
                settings.app_name_for_autorun,
                exe_path_str
            );
        }
        Ok(existing_path_val) => { // Exists but points elsewhere, update it
            tracing::warn!(
                "Startup: Autostart entry for '{}' currently points to '{}'. Updating to '{}'.",
                settings.app_name_for_autorun, existing_path_val, exe_path_str
            );
            key.set_value(&settings.app_name_for_autorun, &exe_path_str.as_ref())
                .map_err(|e| AppError::Io(e))?;
            tracing::info!("Startup: Autostart entry for '{}' updated.", settings.app_name_for_autorun);

        }
        Err(ref e) if e.kind() == std::io::ErrorKind::NotFound => { // Entry doesn't exist, create it
            key.set_value(&settings.app_name_for_autorun, &exe_path_str.as_ref())
                .map_err(|e| AppError::Io(e))?;
            tracing::info!(
                "Startup: Autostart entry for '{}' set to '{}'",
                settings.app_name_for_autorun, exe_path_str
            );
        }
        Err(e) => { // Some other error reading the registry value
            return Err(AppError::Io(e));
        }
    }
    Ok(())
}

// Optional: Function to remove autostart entry (e.g., for uninstaller)
#[allow(dead_code)]
pub fn remove_autostart(settings: &Arc<Settings>) -> Result<(), AppError> {
    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
    let path = r"Software\Microsoft\Windows\CurrentVersion\Run";
    
    // Need write access to delete a value
    let key = hkcu.open_subkey_with_flags(&path, KEY_WRITE)
        .map_err(|e| AppError::Io(e))?;

    match key.delete_value(&settings.app_name_for_autorun) {
        Ok(_) => {
            tracing::info!("Startup: Autostart entry '{}' removed.", settings.app_name_for_autorun);
            Ok(())
        }
        Err(ref e) if e.kind() == std::io::ErrorKind::NotFound => {
            tracing::info!("Startup: Autostart entry '{}' not found, nothing to remove.", settings.app_name_for_autorun);
            Ok(()) // Not an error if it's already gone
        }
        Err(e) => Err(AppError::Io(e)), // Other error deleting value
    }
}
'''
'''--- local_log_server/Cargo.toml ---
[package]
name = "local_log_server"
version = "0.1.0"
edition = "2024"

[dependencies]
actix-web = "4.5.1"
actix-files = "0.6.5"
tokio = { version = "1.36.0", features = ["macros", "rt-multi-thread"] }
serde = { version = "1.0.196", features = ["derive"] }
serde_json = "1.0.113"
chrono = { version = "0.4.33", features = ["serde"] }
uuid = { version = "1.7.0", features = ["v4", "serde"] }
rusqlite = { version = "0.30.0", features = ["bundled", "chrono", "uuid"] }
askama = "0.12.1" # Keep it simple, no extra features for now for 0.12.1
thiserror = "1.0.57"
hex = "0.4.3"
aes-gcm = "0.10.3"
tracing = "0.1.40"
tracing-subscriber = { version = "0.3.18", features = ["env-filter", "fmt"] }
config = "0.13.4"
toml = "0.8.8"
bytes = "1.6.0"
'''
'''--- local_log_server/local_server_config.example.toml ---
# Example configuration for the Local Log Server
# This file will be named 'local_server_config.toml' and placed next to the
# local_log_server.exe executable by the activity_generator_gui.

# Address and port for the server to listen on for API requests (from the client)
# and for serving the Web UI.
# For local operation, "127.0.0.1" is recommended to only allow connections
# from the same machine. "0.0.0.0" would listen on all available network interfaces.
listen_address = "127.0.0.1:8090"

# The AES-256 encryption key in hexadecimal format (64 characters).
# This MUST match the key configured into the activity_monitor_client_core.
# The activity_generator_gui will generate this key and write it here.
# For manual testing of this server, you'll need to put a valid key here.
# Example (DO NOT USE FOR REAL, GENERATE YOUR OWN):
encryption_key_hex = "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f"

# Path to the SQLite database file.
# This path will be treated as relative to the server executable's directory.
database_path = "activity_logs.sqlite"

# How long to keep logs in the database, in days.
# Logs older than this will be periodically deleted.
# Set to 0 to disable automatic deletion (retain logs indefinitely).
log_retention_days = 30

# Optional: If you were to separate the Web UI port from the API listening port.
# For the current setup, `listen_address` handles both.
# web_ui_port = 8090

# Optional: Server's own diagnostic log level (if you implement file logging for the server)
# diagnostic_log_level = "info" # trace, debug, info, warn, error
'''
'''--- local_log_server/src/app_config.rs ---
use crate::errors::ServerError;
use config::{Config, File as ConfigFile, Environment};
use serde::Deserialize;
use std::path::{Path, PathBuf};
use std::sync::Arc;

// Default interval for checking old logs to delete, in hours.
const DEFAULT_LOG_DELETION_CHECK_INTERVAL_HOURS: u64 = 24;

#[derive(Debug, Clone)]
pub struct ServerSettings {
    pub listen_address: String,
    pub encryption_key: [u8; 32],
    pub database_path: PathBuf,
    pub log_retention_days: u32,
    pub log_deletion_check_interval_hours: u64, // Added
}

#[derive(Debug, Deserialize)]
struct RawServerSettings {
    listen_address: String,
    encryption_key_hex: String,
    database_path: String,
    log_retention_days: u32,
    log_deletion_check_interval_hours: Option<u64>, // Added as Option
}

impl ServerSettings {
    pub fn new() -> Result<Arc<Self>, ServerError> {
        let exe_path = std::env::current_exe()
            .map_err(|e| ServerError::Config(format!("Failed to determine executable path: {}", e)))?;
        let exe_dir = exe_path.parent().ok_or_else(|| {
            ServerError::Config("Failed to determine executable directory.".to_string())
        })?;

        let config_file_name = "local_server_config.toml";
        let config_file_path = exe_dir.join(config_file_name);

        if !config_file_path.exists() {
            return Err(ServerError::Config(format!(
                "Configuration file '{}' not found in executable directory: {:?}",
                config_file_name, exe_dir
            )));
        }

        tracing::info!("Loading server configuration from: {:?}", config_file_path);

        let builder = Config::builder()
            .add_source(ConfigFile::from(config_file_path).required(true))
            .add_source(
                Environment::with_prefix("LOCAL_LOG_SERVER")
                    .separator("__")
                    .try_parsing(true),
            );

        let raw_settings: RawServerSettings = builder
            .build()
            .map_err(|e| ServerError::Config(format!("Failed to build server configuration: {}", e)))?
            .try_deserialize()
            .map_err(|e| ServerError::Config(format!("Failed to deserialize server configuration: {}", e)))?;

        let key_bytes = hex::decode(&raw_settings.encryption_key_hex)
            .map_err(|e| ServerError::Config(format!("Invalid encryption_key_hex in config: {}. Ensure it's a 64-character hex string.", e)))?;
        if key_bytes.len() != 32 {
            return Err(ServerError::Config(
                "Decoded encryption key must be 32 bytes long.".to_string(),
            ));
        }
        let mut encryption_key = [0u8; 32];
        encryption_key.copy_from_slice(&key_bytes);

        let settings = ServerSettings {
            listen_address: raw_settings.listen_address,
            encryption_key,
            database_path: exe_dir.join(raw_settings.database_path),
            log_retention_days: raw_settings.log_retention_days,
            log_deletion_check_interval_hours: raw_settings
                .log_deletion_check_interval_hours
                .unwrap_or(DEFAULT_LOG_DELETION_CHECK_INTERVAL_HOURS), // Use default if not present
        };

        Ok(Arc::new(settings))
    }
}
'''
'''--- local_log_server/src/application/log_service.rs ---
use crate::app_config::ServerSettings;
use crate::domain::event_types::LogEvent;
use crate::errors::ServerError;
use crate::infrastructure::{
    database::DbConnection,
    encryption::decrypt_payload,
};
use actix_web::web; // For web::block
use std::sync::Arc;
use tokio::time::{interval, Duration, MissedTickBehavior};

#[derive(Clone)]
pub struct LogService {
    db_conn: DbConnection,
    encryption_key: [u8; 32],
    settings: Arc<ServerSettings>,
}

// Helper to map BlockingError to ServerError
fn map_blocking_error(e: actix_web::error::BlockingError) -> ServerError {
    ServerError::Internal(format!("Blocking task panicked or was cancelled: {}", e))
}

impl LogService {
    pub fn new(db_conn: DbConnection, settings: Arc<ServerSettings>) -> Self {
        let key = settings.encryption_key;
        LogService {
            db_conn,
            encryption_key: key,
            settings,
        }
    }

    pub async fn ingest_log_batch(
        &self,
        client_id_str: &str,
        encrypted_data: Vec<u8>,
    ) -> Result<usize, ServerError> {
        tracing::debug!(
            "LogService: Received encrypted log batch of {} bytes from client_id: {}",
            encrypted_data.len(),
            client_id_str
        );

        let key_clone = self.encryption_key;
        // Closure for decrypt_payload returns Result<Vec<u8>, ServerError>
        // web::block(...).await -> Result<Result<Vec<u8>, ServerError>, BlockingError>
        // .map_err(map_blocking_error) -> Result<Result<Vec<u8>, ServerError>, ServerError>
        // outer ? -> Result<Vec<u8>, ServerError>
        // inner ? -> Vec<u8>
        let decrypted_json_bytes = web::block(move || decrypt_payload(&encrypted_data, &key_clone))
            .await
            .map_err(map_blocking_error)??; // This is correct if we want Vec<u8> here.
        
        tracing::trace!("LogService: Successfully decrypted payload.");

        let log_events: Vec<LogEvent> = serde_json::from_slice(&decrypted_json_bytes)
            .map_err(|e| {
                tracing::error!("LogService: Failed to deserialize log events JSON: {}. Data (first 200B): {:?}",
                    e,
                    String::from_utf8_lossy(
                        &decrypted_json_bytes[..std::cmp::min(200, decrypted_json_bytes.len())]
                    )
                );
                ServerError::Json(e)
            })?;

        let num_events = log_events.len();
        tracing::debug!("LogService: Deserialized {} log events from client_id: {}.", num_events, client_id_str);

        if num_events == 0 {
            tracing::debug!("LogService: Received empty batch of events (after deserialization). Nothing to store.");
            return Ok(0);
        }

        let db_conn_clone = self.db_conn.clone();
        // Closure for insert_log_events returns Result<(), ServerError>
        // web::block(...).await.map_err(...)?? -> unwraps fully to () on success, or propagates ServerError. Correct.
        web::block(move || db_conn_clone.insert_log_events(log_events))
            .await
            .map_err(map_blocking_error)??;

        tracing::info!("LogService: Successfully stored {} log events from client_id: {}.", num_events, client_id_str);
        Ok(num_events)
    }

    pub async fn get_log_events_paginated(
        &self,
        page: u32,
        page_size: u32,
    ) -> Result<Vec<LogEvent>, ServerError> {
        tracing::debug!("LogService: Querying log events - page: {}, page_size: {}", page, page_size);
        let db_conn_clone = self.db_conn.clone();
        // Closure returns Result<Vec<LogEvent>, ServerError>
        // web::block(...).await.map_err(...) -> Result<Result<Vec<LogEvent>, ServerError>, ServerError>
        // ? on this -> Result<Vec<LogEvent>, ServerError>. This matches function signature.
        web::block(move || db_conn_clone.query_log_events(page, page_size))
            .await
            .map_err(map_blocking_error)? // Single ? here
    }

    pub async fn get_total_log_count(&self) -> Result<i64, ServerError> {
        tracing::debug!("LogService: Querying total log event count.");
        let db_conn_clone = self.db_conn.clone();
        // Closure returns Result<i64, ServerError>
        // web::block(...).await.map_err(...) -> Result<Result<i64, ServerError>, ServerError>
        // ? on this -> Result<i64, ServerError>. This matches function signature.
        web::block(move || db_conn_clone.count_total_log_events())
            .await
            .map_err(map_blocking_error)? // Single ? here
    }

    // This is an internal helper, but let's make it consistent.
    // It's called by the spawned task which handles the Result.
    async fn delete_old_logs_from_db(&self) -> Result<usize, ServerError> {
        let db_conn_clone = self.db_conn.clone();
        let settings_clone = Arc::clone(&self.settings);
        // Closure returns Result<usize, ServerError>
        // web::block(...).await.map_err(...) -> Result<Result<usize, ServerError>, ServerError>
        // ? on this -> Result<usize, ServerError>.
        web::block(move || db_conn_clone.delete_old_logs(&settings_clone))
            .await
            .map_err(map_blocking_error)? // Single ? here
    }

    // This public method is for the spawned task, which will handle the Result.
    pub async fn run_scheduled_log_deletion(&self) -> Result<usize, ServerError> {
        tracing::info!("LogService: Starting scheduled task to delete old logs.");
        // Call the internal helper that returns Result<usize, ServerError>
        let deleted_count = self.delete_old_logs_from_db().await?;

        if deleted_count > 0 {
            tracing::info!("LogService: Scheduled deletion removed {} old log entries.", deleted_count);
        } else {
            tracing::debug!("LogService: Scheduled deletion found no old logs to remove.");
        }
        Ok(deleted_count)
    }
}

pub fn spawn_periodic_log_deletion_task(log_service: LogService) {
    if log_service.settings.log_retention_days == 0 {
        tracing::info!("LogService: Periodic log deletion is disabled (retention_days = 0).");
        return;
    }

    let deletion_check_interval_hours = log_service.settings.log_deletion_check_interval_hours;
    let mut interval = interval(Duration::from_secs(deletion_check_interval_hours * 60 * 60));
    interval.set_missed_tick_behavior(MissedTickBehavior::Delay);

    tokio::spawn(async move {
        tracing::info!(
            "LogService: Periodic log deletion task started. Check interval: {} hours.",
            deletion_check_interval_hours
        );
        loop {
            interval.tick().await;
            tracing::info!("LogService: Triggering periodic deletion of old logs...");
            // run_scheduled_log_deletion now returns Result<usize, ServerError>
            match log_service.run_scheduled_log_deletion().await {
                Ok(count) => {
                    // This trace is fine, count is known.
                    tracing::debug!("LogService: Periodic deletion task completed, {} entries affected.", count);
                }
                Err(e) => {
                    tracing::error!("LogService: Error during periodic log deletion: {}", e);
                }
            }
        }
    });
}
'''
'''--- local_log_server/src/application/mod.rs ---
// src/application/mod.rs

pub mod log_service;
'''
'''--- local_log_server/src/domain/event_types.rs ---
// src/domain/event_types.rs

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

/// Represents a single, distinct block of user activity or a system event.
/// The `timestamp` field typically denotes the start of this activity block.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct LogEvent {
    /// Unique identifier for this log event.
    pub id: Uuid,
    /// Identifier for the client that generated this event.
    pub client_id: Uuid,
    /// Primary timestamp for the event, often the start of an activity session.
    pub timestamp: DateTime<Utc>,
    /// Name of the application associated with this activity block.
    pub application_name: String,
    /// The title of the application window when this activity block began.
    pub initial_window_title: String,
    /// The specific type and data of the event.
    pub event_data: EventData,
    /// Version of this log event schema, for future compatibility.
    #[serde(default = "default_schema_version")]
    pub schema_version: u32,
}

/// Current schema version for LogEvent.
fn default_schema_version() -> u32 {
    2 // Matches the client's schema version for ApplicationActivity
}

/// Enum representing the different kinds of data that can be logged.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(tag = "type", content = "data")] // For clear JSON structure: { "type": "ApplicationActivity", "data": { ... } }
pub enum EventData {
    /// Represents a consolidated block of user activity within a single application.
    ApplicationActivity {
        /// Timestamp when this specific application session/activity block started.
        start_time: DateTime<Utc>,
        /// Timestamp when this specific application session/activity block ended
        /// (e.g., due to application switch, periodic flush, or client shutdown).
        end_time: DateTime<Utc>,
        /// All characters typed by the user during this session in this application,
        /// potentially including representations of special keys like "[ENTER]".
        typed_text: String,
        /// A list of clipboard copy actions that occurred during this application session.
        clipboard_actions: Vec<ClipboardActivity>,
        // /// Optional: A list of all distinct window titles encountered during this session,
        // /// if the title changed while the user was still in the same application.
        // distinct_window_titles_during_session: Option<Vec<String>>,
    },
    /*
    // Example of how you might add other top-level event types later:
    ClientStatus {
        status_time: DateTime<Utc>,
        status_type: ClientStatusType, // e.g., Started, Stopped, Heartbeat
        message: Option<String>,
    },
    */
}

/// Represents a single clipboard copy action.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ClipboardActivity {
    /// Precise timestamp of when this clipboard copy occurred.
    pub timestamp: DateTime<Utc>,
    /// SHA256 hash of the full clipboard content to detect duplicates or for brevity.
    pub content_hash: String,
    /// A short preview of the copied text content.
    pub content_preview: String,
    /// The total number of characters in the copied content.
    pub char_count: usize,
}

/*
// Example for future extensibility
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum ClientStatusType {
    Started,
    Stopped,
    Heartbeat,
    ErrorCondition,
}
*/
'''
'''--- local_log_server/src/domain/mod.rs ---
// src/domain/mod.rs
pub mod event_types;
'''
'''--- local_log_server/src/errors.rs ---
// src/errors.rs
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ServerError {
    #[error("Configuration Error: {0}")]
    Config(String),

    #[error("I/O Error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Database Error: {0}")]
    Database(#[from] rusqlite::Error),

    #[error("JSON Serialization/Deserialization Error: {0}")]
    Json(#[from] serde_json::Error),

    #[error("TOML Deserialization Error: {0}")]
    TomlDe(#[from] toml::de::Error),

    #[error("Hex Decoding Error: {0}")]
    Hex(#[from] hex::FromHexError),

    #[error("Encryption/Decryption Error: {0}")]
    Crypto(String),

    #[error("HTTP Server Initialization Error: {0}")]
    HttpServerInit(String), // For errors during server setup

    #[error("API Request Error: {0}")]
    ApiRequest(String), // For issues with incoming API requests (e.g., bad payload)

    #[error("Template Rendering Error: {0}")]
    Template(#[from] askama::Error),

    #[error("Internal Server Error: {0}")]
    Internal(String), // Catch-all for unexpected issues
}

// Implement conversion from actix_web error types to ServerError if needed
// This helps in propagating errors cleanly within actix handlers
impl From<actix_web::Error> for ServerError {
    fn from(err: actix_web::Error) -> Self {
        ServerError::HttpServerInit(err.to_string()) // Or a more specific variant
    }
}
impl From<actix_web::error::PayloadError> for ServerError {
   fn from(err: actix_web::error::PayloadError) -> Self {
       ServerError::ApiRequest(format!("Payload error: {}", err))
   }
}

// We can also implement actix_web::ResponseError for ServerError
// to allow our handlers to return Result<_, ServerError> directly.
impl actix_web::ResponseError for ServerError {
    fn status_code(&self) -> actix_web::http::StatusCode {
        match *self {
            ServerError::Config(_) => actix_web::http::StatusCode::INTERNAL_SERVER_ERROR,
            ServerError::Io(_) => actix_web::http::StatusCode::INTERNAL_SERVER_ERROR,
            ServerError::Database(_) => actix_web::http::StatusCode::INTERNAL_SERVER_ERROR,
            ServerError::Json(_) => actix_web::http::StatusCode::BAD_REQUEST, // Or internal if it's our serialization
            ServerError::TomlDe(_) => actix_web::http::StatusCode::INTERNAL_SERVER_ERROR,
            ServerError::Hex(_) => actix_web::http::StatusCode::BAD_REQUEST,
            ServerError::Crypto(_) => actix_web::http::StatusCode::BAD_REQUEST, // Or internal if server-side crypto fails
            ServerError::HttpServerInit(_) => actix_web::http::StatusCode::INTERNAL_SERVER_ERROR,
            ServerError::ApiRequest(_) => actix_web::http::StatusCode::BAD_REQUEST,
            ServerError::Template(_) => actix_web::http::StatusCode::INTERNAL_SERVER_ERROR,
            ServerError::Internal(_) => actix_web::http::StatusCode::INTERNAL_SERVER_ERROR,
        }
    }

    fn error_response(&self) -> actix_web::HttpResponse {
        tracing::error!("Responding with error: {}", self);
        actix_web::HttpResponse::build(self.status_code())
            .insert_header(actix_web::http::header::ContentType::plaintext())
            .body(self.to_string())
    }
}
'''
'''--- local_log_server/src/infrastructure/database.rs ---
// src/infrastructure/database.rs

use crate::app_config::ServerSettings;
use crate::domain::event_types::{LogEvent, EventData as DomainEventData}; // Alias EventData
use crate::errors::ServerError;
use rusqlite::{params, Connection}; // Removed OptionalExtension, RusqliteResult, ToSql as not directly used
use std::path::Path;
use std::sync::{Arc, Mutex};
use chrono::{Utc}; // Removed DateTime as Utc::now() is used
// use uuid::Uuid; // Not directly used here, Uuid comes from LogEvent

#[derive(Clone)]
pub struct DbConnection(Arc<Mutex<Connection>>);

impl DbConnection {
    pub fn new(db_path: &Path) -> Result<Self, ServerError> {
        tracing::info!("Opening database at: {:?}", db_path);
        let conn = Connection::open(db_path)?;
        let db_conn = DbConnection(Arc::new(Mutex::new(conn)));
        db_conn.init_tables()?;
        Ok(db_conn)
    }

    fn init_tables(&self) -> Result<(), ServerError> {
        let conn = self.0.lock().map_err(|_e| ServerError::Internal("DB Mutex poisoned".to_string()))?;
        conn.execute_batch(
            "BEGIN;
            CREATE TABLE IF NOT EXISTS logs (
                id TEXT PRIMARY KEY,
                client_id TEXT NOT NULL,
                event_timestamp INTEGER NOT NULL,
                application_name TEXT NOT NULL,
                initial_window_title TEXT,
                schema_version INTEGER NOT NULL,
                session_start_time INTEGER NOT NULL,
                session_end_time INTEGER NOT NULL,
                typed_text TEXT,
                clipboard_actions_json TEXT,
                raw_event_json TEXT NOT NULL
            );
            CREATE INDEX IF NOT EXISTS idx_logs_event_timestamp ON logs (event_timestamp);
            CREATE INDEX IF NOT EXISTS idx_logs_client_id ON logs (client_id);
            CREATE INDEX IF NOT EXISTS idx_logs_application_name ON logs (application_name);
            COMMIT;"
        )?;
        tracing::info!("Database tables initialized successfully.");
        Ok(())
    }

    pub fn insert_log_events(&self, events_vec: Vec<LogEvent>) -> Result<(), ServerError> {
        if events_vec.is_empty() {
            return Ok(());
        }
        let num_events_to_insert = events_vec.len();
        let mut conn = self.0.lock().map_err(|_e| ServerError::Internal("DB Mutex poisoned".to_string()))?;
        
        let tx = conn.transaction()?;

        for event in events_vec { // events_vec is moved here
            let (session_start_time_ts, session_end_time_ts, typed_text_opt, clipboard_json_opt) =
                match &event.event_data {
                    DomainEventData::ApplicationActivity { // Use aliased DomainEventData
                        start_time,
                        end_time,
                        typed_text,
                        clipboard_actions,
                    } => (
                        start_time.timestamp(),
                        end_time.timestamp(),
                        Some(typed_text.clone()),
                        Some(serde_json::to_string(clipboard_actions)?),
                    ),
                    // If other variants existed, they would be handled here
                    // _ => return Err(ServerError::Internal(format!("Unknown EventData variant for event id: {}", event.id))),
                };
            
            let raw_event_json = serde_json::to_string(&event)?;

            tx.execute(
                "INSERT OR IGNORE INTO logs (
                    id, client_id, event_timestamp, application_name, initial_window_title, schema_version,
                    session_start_time, session_end_time, typed_text, clipboard_actions_json, raw_event_json
                ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11)",
                params![
                    event.id.to_string(),
                    event.client_id.to_string(),
                    event.timestamp.timestamp(),
                    event.application_name,
                    event.initial_window_title,
                    event.schema_version,
                    session_start_time_ts,
                    session_end_time_ts,
                    typed_text_opt,
                    clipboard_json_opt,
                    raw_event_json,
                ],
            )?;
        }
        tx.commit()?;
        tracing::debug!("Successfully inserted {} log events into the database.", num_events_to_insert);
        Ok(())
    }

    pub fn query_log_events(&self, page: u32, page_size: u32) -> Result<Vec<LogEvent>, ServerError> {
        let conn = self.0.lock().map_err(|_e| ServerError::Internal("DB Mutex poisoned".to_string()))?;
        let offset = (page.saturating_sub(1)) * page_size;

        let mut stmt = conn.prepare(
            "SELECT raw_event_json FROM logs ORDER BY event_timestamp DESC LIMIT ?1 OFFSET ?2"
        )?;
        
        let event_iter = stmt.query_map(params![page_size, offset], |row| {
            let raw_json: String = row.get(0)?;
            serde_json::from_str::<LogEvent>(&raw_json)
                .map_err(|e| rusqlite::Error::FromSqlConversionFailure(0, rusqlite::types::Type::Text, Box::new(e)))
        })?;

        let mut events = Vec::new();
        for event_result in event_iter {
            events.push(event_result?);
        }
        tracing::debug!("Queried {} log events (page {}, page_size {}).", events.len(), page, page_size);
        Ok(events)
    }

    pub fn count_total_log_events(&self) -> Result<i64, ServerError> {
        let conn = self.0.lock().map_err(|_e| ServerError::Internal("DB Mutex poisoned".to_string()))?;
        let count: i64 = conn.query_row("SELECT COUNT(*) FROM logs", [], |row| row.get(0))?;
        Ok(count)
    }

    pub fn delete_old_logs(&self, settings: &Arc<ServerSettings>) -> Result<usize, ServerError> {
        if settings.log_retention_days == 0 {
            tracing::debug!("Log retention is indefinite (0 days), skipping deletion of old logs.");
            return Ok(0);
        }
        let conn = self.0.lock().map_err(|_e| ServerError::Internal("DB Mutex poisoned".to_string()))?;
        let retention_period_duration = chrono::Duration::days(settings.log_retention_days as i64);
        let cutoff_timestamp = (Utc::now() - retention_period_duration).timestamp();

        tracing::info!("Deleting logs older than {} days (before timestamp {}).", settings.log_retention_days, cutoff_timestamp);
        
        let rows_deleted = conn.execute(
            "DELETE FROM logs WHERE event_timestamp < ?1",
            params![cutoff_timestamp],
        )?;
        
        tracing::info!("Deleted {} old log entries.", rows_deleted);
        Ok(rows_deleted)
    }
}
'''
'''--- local_log_server/src/infrastructure/encryption.rs ---
// src/infrastructure/encryption.rs

use crate::errors::ServerError; // Assuming ServerError is in crate::errors
use aes_gcm::aead::{Aead, KeyInit};
use aes_gcm::{Aes256Gcm, Nonce};

const NONCE_SIZE: usize = 12; // Standard for AES-GCM (96-bit)

/// Decrypts a payload that was encrypted with AES-256-GCM.
/// The payload is expected to be: NONCE (12 bytes) || CIPHERTEXT_WITH_TAG.
/// The authentication tag is expected to be appended to the ciphertext.
pub fn decrypt_payload(encrypted_data_with_nonce: &[u8], key: &[u8; 32]) -> Result<Vec<u8>, ServerError> {
    if encrypted_data_with_nonce.len() < NONCE_SIZE {
        tracing::warn!("Encrypted data too short to contain nonce. Length: {}", encrypted_data_with_nonce.len());
        return Err(ServerError::Crypto("Encrypted data too short for nonce.".to_string()));
    }

    let cipher = Aes256Gcm::new_from_slice(key)
        .map_err(|e| {
            tracing::error!("Failed to create AES cipher for decryption: {}", e);
            ServerError::Crypto(format!("Failed to create AES cipher: {}", e))
        })?;

    let (nonce_bytes, ciphertext_with_tag) = encrypted_data_with_nonce.split_at(NONCE_SIZE);
    let nonce = Nonce::from_slice(nonce_bytes);

    // The `decrypt` method of `Aes256Gcm` expects the authentication tag
    // to be part of the `ciphertext_with_tag` slice.
    cipher.decrypt(nonce, ciphertext_with_tag)
        .map_err(|e| {
            // This error often means the key is wrong, the data is corrupt, or the MAC check failed.
            tracing::warn!("AES decryption/MAC verification failed: {}. Potential key mismatch or data corruption.", e);
            ServerError::Crypto(format!("AES decryption/MAC verification failed: {}", e))
        })
}
'''
'''--- local_log_server/src/infrastructure/mod.rs ---
// src/infrastructure/mod.rs

pub mod database;
pub mod encryption;
'''
'''--- local_log_server/src/main.rs ---
// src/main.rs (for local_log_server)

use actix_files::Files;
use actix_web::{middleware::Logger as ActixLogger, web, App, HttpServer};
use std::sync::Arc;
use tracing_subscriber::EnvFilter; // Ensure EnvFilter is imported

mod app_config;
mod errors;
mod domain;
mod infrastructure;
mod application;
mod presentation;

use crate::app_config::ServerSettings;
use crate::infrastructure::database::DbConnection;
use crate::application::log_service::{LogService, spawn_periodic_log_deletion_task};
use crate::presentation::{
    api_handlers::ingest_logs_route,
    web_ui_handlers::{index_route, view_logs_route},
};

fn init_server_diagnostics(log_level_str: &str) {
    // Try to get filter from RUST_LOG, otherwise use the passed string
    let effective_filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new(log_level_str));
    
    // Store the string representation for logging *before* the filter might be consumed
    let filter_description_for_log = effective_filter.to_string();

    tracing_subscriber::fmt()
        .with_env_filter(effective_filter) // Pass the filter; with_env_filter takes it by value
        .with_thread_ids(true)
        .with_target(true)
        .with_line_number(true)
        .init();
    
    tracing::info!("Local Log Server diagnostic logging initialized. Effective filter set to: '{}'", filter_description_for_log);
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let settings = match ServerSettings::new() {
        Ok(s) => s,
        Err(e) => {
            eprintln!("FATAL: Server configuration error: {}. Ensure 'local_server_config.toml' exists and is valid next to the executable.", e);
            return Err(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()));
        }
    };

    // Assuming you might add a diagnostic_log_level to ServerSettings later
    // For now, using "info" or what RUST_LOG dictates.
    let diagnostic_log_level = "info"; // Or: &settings.diagnostic_log_level;
    init_server_diagnostics(diagnostic_log_level);
    
    tracing::info!("Local Log Server starting up...");
    tracing::debug!(
        "Server Settings: Listen Address='{}', DB Path='{:?}', Log Retention: {} days",
        settings.listen_address,
        settings.database_path,
        settings.log_retention_days
    );

    let db_connection = match DbConnection::new(&settings.database_path) {
        Ok(conn) => conn,
        Err(e) => {
            tracing::error!("CRITICAL: Failed to initialize database at {:?}: {}", settings.database_path, e);
            return Err(std::io::Error::new(std::io::ErrorKind::Other, e.to_string()));
        }
    };
    tracing::info!("Database connection established and tables initialized.");

    let log_service_shared = web::Data::new(LogService::new(db_connection.clone(), Arc::clone(&settings)));
    tracing::info!("LogService initialized and wrapped for Actix.");

    spawn_periodic_log_deletion_task(LogService::new(db_connection, Arc::clone(&settings)));
    tracing::info!("Periodic log deletion task spawned.");
    
    let listen_address = settings.listen_address.clone();
    tracing::info!("Attempting to bind HTTP server to: {}", listen_address);

    let server_future = HttpServer::new(move || {
        App::new()
            .wrap(ActixLogger::default())
            .app_data(log_service_shared.clone())
            .service(ingest_logs_route)
            .service(index_route)
            .service(view_logs_route)
            .service(Files::new("/static", "./static"))
    })
    .bind(&listen_address)?
    .workers(2)
    .run();

    tracing::info!("Local Log Server started successfully on http://{}", listen_address.replace("0.0.0.0", "127.0.0.1"));
    tracing::info!("API endpoint for client: http://{}/api/log", listen_address.replace("0.0.0.0", "127.0.0.1"));
    tracing::info!("Press Ctrl+C to stop the server.");

    server_future.await?;
    tracing::info!("Local Log Server has shut down.");
    Ok(())
}
'''
'''--- local_log_server/src/presentation/api_handlers.rs ---
use crate::application::log_service::LogService;
// use crate::errors::ServerError; // ServerError is used via Result's Err variant
use actix_web::{web, post, HttpResponse, Responder, HttpRequest};
use bytes::Bytes;

const MAX_PAYLOAD_SIZE: usize = 10 * 1024 * 1024;

#[post("/api/log")]
pub async fn ingest_logs_route(
    req: HttpRequest,
    log_service: web::Data<LogService>,
    payload: Bytes,
) -> Result<HttpResponse, crate::errors::ServerError> { // Explicit Result with ServerError
    let client_id = match req.headers().get("X-Client-ID") {
        Some(val) => match val.to_str() {
            Ok(s) => s.to_string(),
            Err(_) => {
                tracing::warn!("API: Received X-Client-ID header with non-UTF8 characters.");
                // Directly return HttpResponse for early exits before main logic
                return Ok(HttpResponse::BadRequest().body("X-Client-ID header contains invalid characters."));
            }
        },
        None => {
            tracing::warn!("API: Received log submission without X-Client-ID header.");
            "UnknownClient".to_string()
        }
    };

    if payload.is_empty() {
        tracing::warn!("API: Received empty payload from client_id: {}", client_id);
        return Ok(HttpResponse::BadRequest().body("Empty payload received."));
    }

    if payload.len() > MAX_PAYLOAD_SIZE {
        tracing::warn!("API: Payload from client_id: {} exceeds max size of {} bytes. Received: {} bytes.", 
            client_id, MAX_PAYLOAD_SIZE, payload.len());
        return Ok(HttpResponse::PayloadTooLarge().body(format!("Payload exceeds maximum size of {} bytes.", MAX_PAYLOAD_SIZE)));
    }

    tracing::info!("API: Received log data from client_id: {}, payload size: {} bytes.", client_id, payload.len());

    match log_service.ingest_log_batch(&client_id, payload.to_vec()).await {
        Ok(num_events_ingested) => {
            tracing::info!("API: Successfully ingested {} events for client_id: {}", num_events_ingested, client_id);
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "status": "success",
                "message": format!("Successfully processed {} log events.", num_events_ingested)
            })))
        }
        Err(e) => {
            tracing::error!("API: Error processing log batch for client_id: {}: {}", client_id, e);
            Err(e) // Propagate ServerError, Actix will use its ResponseError impl
        }
    }
}
'''
'''--- local_log_server/src/presentation/mod.rs ---
// src/presentation/mod.rs

pub mod api_handlers;
pub mod web_ui_handlers;
'''
'''--- local_log_server/src/presentation/web_ui_handlers.rs ---
use crate::application::log_service::LogService;
use crate::domain::event_types::{EventData, LogEvent, ClipboardActivity};
use crate::errors::ServerError;
use actix_web::{web, get, HttpResponse, Responder};
use askama::Template;
use serde::Deserialize;
use std::marker::PhantomData;

#[derive(Debug)]
struct DisplayClipboardActivity<'a> {
    timestamp_str: String,
    content_preview: &'a str,
    char_count: usize,
    content_hash_short: String,
}

struct DisplayLogEvent<'a> {
    id_str: String,
    client_id_str: String,
    application_name: &'a str,
    initial_window_title: &'a str,
    schema_version: u32,
    session_start_str: String,
    session_end_str: String,
    typed_text: &'a str,
    clipboard_actions: Vec<DisplayClipboardActivity<'a>>,
    log_timestamp_str: String,
}

#[derive(Template)]
#[template(path = "logs_view.html")]
struct LogsViewTemplate<'a> {
    display_events: Vec<DisplayLogEvent<'a>>,
    current_page: u32,
    total_pages: u32,
    page_size: u32, // Added page_size for constructing links
    _marker: PhantomData<&'a EventData>,
}

#[derive(Template)]
#[template(path = "error_page.html")]
struct ErrorPageTemplate<'a> {
    error_title: &'a str,
    error_message: &'a str,
}

#[derive(Deserialize, Debug)]
pub struct PaginationParams {
    #[serde(default = "default_page")]
    page: u32,
    #[serde(default = "default_page_size")]
    page_size: u32,
}
fn default_page() -> u32 { 1 }
fn default_page_size() -> u32 { 25 } // Default page size for display

#[get("/")]
pub async fn index_route() -> impl Responder {
    HttpResponse::Found()
        .append_header((actix_web::http::header::LOCATION, "/logs"))
        .finish()
}

#[get("/logs")]
pub async fn view_logs_route(
    log_service: web::Data<LogService>,
    query_params: web::Query<PaginationParams>,
) -> Result<HttpResponse, ServerError> {
    tracing::info!(
        "WebUI: Request to view logs - page: {}, page_size: {}",
        query_params.page,
        query_params.page_size
    );

    let current_page = query_params.page.max(1);
    let page_size = query_params.page_size.max(1).min(100); // Keep page_size constrained

    let events = log_service.get_log_events_paginated(current_page, page_size).await?;
    let total_count = log_service.get_total_log_count().await?;

    let total_pages = (total_count as f64 / page_size as f64).ceil() as u32;

    let display_events: Vec<DisplayLogEvent> = events.iter().map(|event| {
        let (session_start_str, session_end_str, typed_text_ref, display_clips) =
            if let EventData::ApplicationActivity { start_time, end_time, typed_text, clipboard_actions } = &event.event_data {
                (
                    start_time.format("%Y-%m-%d %H:%M:%S").to_string(),
                    end_time.format("%Y-%m-%d %H:%M:%S").to_string(),
                    typed_text.as_str(),
                    clipboard_actions.iter().map(|clip| DisplayClipboardActivity {
                        timestamp_str: clip.timestamp.format("%H:%M:%S").to_string(),
                        content_preview: &clip.content_preview,
                        char_count: clip.char_count,
                        content_hash_short: clip.content_hash.chars().take(8).collect(),
                    }).collect()
                )
        } else {
            (String::new(), String::new(), "", Vec::new())
        };

        DisplayLogEvent {
            id_str: event.id.to_string(),
            client_id_str: event.client_id.to_string(),
            application_name: &event.application_name,
            initial_window_title: &event.initial_window_title,
            schema_version: event.schema_version,
            session_start_str,
            session_end_str,
            typed_text: typed_text_ref,
            clipboard_actions: display_clips,
            log_timestamp_str: event.timestamp.format("%Y-%m-%d %H:%M:%S").to_string(),
        }
    }).collect();

    let template = LogsViewTemplate {
        display_events,
        current_page,
        total_pages: total_pages.max(1),
        page_size, // Pass current page_size to template
        _marker: PhantomData,
    };

    match template.render() {
        Ok(html_body) => Ok(HttpResponse::Ok().content_type("text/html; charset=utf-8").body(html_body)),
        Err(askama_err) => {
            tracing::error!("WebUI: Error rendering logs_view template: {}", askama_err);
            Err(ServerError::from(askama_err))
        }
    }
}
'''
'''--- local_log_server/static/css/style.css ---
:root {
    --bg-color: #1e1e2e; /* Dark background */
    --bg-color-light: #2a2a3c; /* Slightly lighter dark for cards/sections */
    --text-color: #cdd6f4; /* Light text for readability */
    --text-color-muted: #a6adc8; /* Muted text for less important info */
    --text-color-dark: #11111b; /* For light backgrounds if any */

    --primary-accent: #89dceb; /* Teal */
    --primary-accent-hover: #96e2f0;
    --primary-accent-darker: #77c2cf;

    --border-color: #45475a; /* Subtle borders */
    --card-shadow: 0 2px 8px rgba(0,0,0,0.3);

    --font-sans: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    --font-mono: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;

    --spacing-unit: 8px;
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

html {
    font-size: 16px; /* Base font size */
}

body {
    font-family: var(--font-sans);
    line-height: 1.6;
    background-color: var(--bg-color);
    color: var(--text-color);
    display: flex;
    flex-direction: column;
    min-height: 100vh;
}

.site-wrapper {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.container {
    width: 90%;
    max-width: 1200px; /* Limit max width for very wide screens */
    margin: 0 auto;
    padding-left: calc(var(--spacing-unit) * 2);
    padding-right: calc(var(--spacing-unit) * 2);
}

.site-header {
    background-color: var(--bg-color-light);
    color: var(--primary-accent);
    padding: calc(var(--spacing-unit) * 2) 0;
    border-bottom: 1px solid var(--border-color);
    box-shadow: var(--card-shadow);
}

.site-header h1 {
    font-size: 1.8rem;
    font-weight: 600;
    text-align: center;
}

.site-content {
    padding-top: calc(var(--spacing-unit) * 3);
    padding-bottom: calc(var(--spacing-unit) * 3);
    flex: 1;
}

/* Log Entry Styling */
.log-entries-container {
    display: grid;
    gap: calc(var(--spacing-unit) * 2.5);
}

.log-entry {
    background-color: var(--bg-color-light);
    border: 1px solid var(--border-color);
    border-radius: calc(var(--spacing-unit) / 2);
    padding: calc(var(--spacing-unit) * 2);
    box-shadow: var(--card-shadow);
    transition: transform 0.2s ease-in-out;
}
/* .log-entry:hover {
    transform: translateY(-2px);
} */

.log-entry-header {
    border-bottom: 1px solid var(--border-color);
    padding-bottom: var(--spacing-unit);
    margin-bottom: calc(var(--spacing-unit) * 1.5);
}

.log-entry-header .app-name {
    color: var(--primary-accent);
    font-size: 1.4rem;
    margin-bottom: calc(var(--spacing-unit) / 2);
}

.log-entry-header .window-title {
    font-size: 0.9rem;
    color: var(--text-color-muted);
}
.log-entry-header .window-title strong {
    color: var(--text-color);
}

.log-entry-details p {
    margin-bottom: calc(var(--spacing-unit) / 2);
    font-size: 0.9rem;
}
.log-entry-details strong {
    color: var(--primary-accent-darker);
    font-weight: 500;
}

.log-data h4 {
    font-size: 1rem;
    color: var(--primary-accent);
    margin-top: calc(var(--spacing-unit) * 1.5);
    margin-bottom: calc(var(--spacing-unit) /2);
}

.typed-text-section .typed-text-content {
    background-color: var(--bg-color); /* Even darker for pre blocks */
    border: 1px solid var(--border-color);
    padding: var(--spacing-unit);
    border-radius: calc(var(--spacing-unit) / 2);
    white-space: pre-wrap;
    word-wrap: break-word;
    max-height: 250px; /* Slightly more room */
    overflow-y: auto;
    font-size: 0.85rem;
    color: var(--text-color); /* Ensure pre text is also light */
}

.clipboard-section .clipboard-list {
    list-style: none; /* Remove default bullets */
    padding-left: 0;
    font-size: 0.85rem;
}

.clipboard-section .clipboard-list li {
    padding: calc(var(--spacing-unit) / 2) 0;
    border-bottom: 1px dashed var(--border-color);
}
.clipboard-section .clipboard-list li:last-child {
    border-bottom: none;
}

.clip-time {
    font-weight: 500;
    color: var(--primary-accent-darker);
}
.clip-preview {
    color: var(--text-color);
}
.clip-meta {
    font-size: 0.8rem;
    color: var(--text-color-muted);
}

.log-entry-footer {
    margin-top: calc(var(--spacing-unit) * 1.5);
    padding-top: var(--spacing-unit);
    border-top: 1px solid var(--border-color);
}

.event-meta {
    font-size: 0.75rem;
    color: var(--text-color-muted);
    text-align: right;
}

.monospace {
    font-family: var(--font-mono);
}

/* Pagination */
.pagination {
    margin: calc(var(--spacing-unit) * 3) 0;
    text-align: center;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: var(--spacing-unit);
}

.pagination .pagination-link {
    color: var(--primary-accent);
    text-decoration: none;
    padding: var(--spacing-unit) calc(var(--spacing-unit) * 1.5);
    border: 1px solid var(--primary-accent);
    border-radius: calc(var(--spacing-unit) / 2);
    transition: background-color 0.2s, color 0.2s;
}

.pagination .pagination-link:hover {
    background-color: var(--primary-accent);
    color: var(--text-color-dark);
}

.pagination .pagination-link.disabled {
    color: var(--text-color-muted);
    border-color: var(--border-color);
    pointer-events: none;
}
.pagination .pagination-link.disabled:hover {
    background-color: transparent;
}

.pagination .page-info {
    padding: var(--spacing-unit) calc(var(--spacing-unit) * 1.5);
    color: var(--text-color-muted);
}

.no-logs-message {
    text-align: center;
    font-size: 1.1rem;
    color: var(--text-color-muted);
    padding: calc(var(--spacing-unit) * 4) 0;
}

.error-page .error-message {
    color: #ff79c6; /* Pink for errors in dark theme */
    background-color: var(--bg-color-light);
    border: 1px solid #ff79c6;
    padding: calc(var(--spacing-unit) * 2);
    margin-bottom: calc(var(--spacing-unit) * 2);
    border-radius: calc(var(--spacing-unit) / 2);
}
.error-page h2 {
    color: #ff79c6;
}
.error-page a {
    color: var(--primary-accent);
}

.site-footer {
    background-color: var(--bg-color);
    color: var(--text-color-muted);
    text-align: center;
    padding: calc(var(--spacing-unit) * 2) 0;
    font-size: 0.85rem;
    border-top: 1px solid var(--border-color);
}

/* Scrollbar styling (optional, WebKit browsers) */
::-webkit-scrollbar {
    width: 10px;
    height: 10px;
}
::-webkit-scrollbar-track {
    background: var(--bg-color);
}
::-webkit-scrollbar-thumb {
    background: var(--border-color);
    border-radius: 5px;
}
::-webkit-scrollbar-thumb:hover {
    background: var(--primary-accent-darker);
}
'''
'''--- local_log_server/templates/base.html ---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Local Activity Log Viewer{% endblock %}</title>
    <link rel="stylesheet" href="/static/css/style.css">
    {% block head_extra %}{% endblock %}
</head>
<body>
    <div class="site-wrapper">
        <header class="site-header">
            <div class="container">
                <h1>{% block header_title %}Activity Logs{% endblock %}</h1>
            </div>
        </header>
        <main class="site-content">
            <div class="container">
                {% block content %}{% endblock %}
            </div>
        </main>
        <footer class="site-footer">
            <div class="container">
                <p>Local Log Server</p>
            </div>
        </footer>
    </div>
    {% block scripts %}{% endblock %}
</body>
</html>
'''
'''--- local_log_server/templates/error_page.html ---
{% extends "base.html" %}

{% block title %}Error{% endblock %}
{% block header_title %}An Error Occurred{% endblock %}

{% block content %}
    <div class="error-page">
        <h2>{{ error_title }}</h2>
        <p class="error-message">{{ error_message }}</p>
        <p><a href="/logs">Return to logs</a></p>
    </div>
{% endblock %}
'''
'''--- local_log_server/templates/logs_view.html ---
{% extends "base.html" %}

{% block title %}View Logs - Page {{ current_page }}{% endblock %}
{% block header_title %}Activity Log Viewer - Page {{ current_page }} of {{ total_pages }}{% endblock %}

{% block content %}
    <div class="log-entries-container">
    {% if display_events.is_empty() %}
        <p class="no-logs-message">No log events found for this page.</p>
    {% else %}
        {% for event in display_events %}
            <article class="log-entry">
                <header class="log-entry-header">
                    <h3 class="app-name">{{ event.application_name }}</h3>
                    <p class="window-title"><strong>Window:</strong> {{ event.initial_window_title }}</p>
                </header>
                <section class="log-entry-details">
                    <p><strong>Client ID:</strong> <span class="monospace">{{ event.client_id_str }}</span></p>
                    <p><strong>Schema:</strong> v{{ event.schema_version }}</p>
                    <p><strong>Session:</strong> {{ event.session_start_str }} → {{ event.session_end_str }} UTC</p>
                </section>

                {% if !event.typed_text.is_empty() %}
                <section class="log-data typed-text-section">
                    <h4>Typed Text:</h4>
                    <pre class="typed-text-content monospace">{{ event.typed_text }}</pre>
                </section>
                {% endif %}

                {% if !event.clipboard_actions.is_empty() %}
                <section class="log-data clipboard-section">
                    <h4>Clipboard Actions ({{ event.clipboard_actions.len() }}):</h4>
                    <ul class="clipboard-list">
                        {% for clip in event.clipboard_actions %}
                            <li>
                                <span class="clip-time">{{ clip.timestamp_str }}</span>:
                                <em class="clip-preview">{{ clip.content_preview }}</em>
                                <span class="clip-meta"> ({{ clip.char_count }} chars, hash: <span class="monospace">{{ clip.content_hash_short }}</span>...)</span>
                            </li>
                        {% endfor %}
                    </ul>
                </section>
                {% endif %}
                <footer class="log-entry-footer">
                    <p class="event-meta"><em>Log ID: <span class="monospace">{{ event.id_str }}</span>, Logged (Session Start): {{ event.log_timestamp_str }} UTC</em></p>
                </footer>
            </article>
        {% endfor %}
    {% endif %}
    </div>

    {% if total_pages > 1 %}
    <nav class="pagination">
        {% if current_page > 1 %}
            <a href="/logs?page={{ current_page - 1 }}&page_size={{ page_size }}" class="pagination-link prev">« Previous</a>
        {% else %}
            <span class="pagination-link disabled prev">« Previous</span>
        {% endif %}

        {# Basic pagination display - could be expanded to show more page numbers #}
        {# For simplicity, just showing current page and total #}
        <span class="page-info">Page {{ current_page }} of {{ total_pages }}</span>

        {% if current_page < total_pages %}
            <a href="/logs?page={{ current_page + 1 }}&page_size={{ page_size }}" class="pagination-link next">Next »</a>
        {% else %}
            <span class="pagination-link disabled next">Next »</span>
        {% endif %}
    </nav>
    {% endif %}
{% endblock %}
'''